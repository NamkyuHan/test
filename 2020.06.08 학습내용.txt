
esr 케이안 주파집 벨킨

https://github.com/nqwrt/DIG


Hello World!
I am a programer!!!!!!!



public class HelloWorld {
	public static void main(String[] args) {
		System.out.print("Hello World");

	}
}		


public class 안녕 {
	public static void main(String[] args) {
		System.out.println("안녕 자바야");
			System.out.println("안녕 반가워 난 자바야");
	}
}





2020-05-12
""  = 문자열       '' = 문자    없으면 숫자 


1.일반 프로그램이 (옆의 하드웨어 용어를 사용하여) 실행 되는 원리를 설명하시오.(CPU,메모리,HDD )

하드웨어를 기본 바탕으로 일반 프로그램을 실행할 수 있는 적절한 OS프로그램을 설치한다
원활한 프로그램 실행을 위해 보조기억장치에 실행 프로그램을 설치해 놓는다

보조기억장치(HDD, SSD)에 저장되어 있는 프로그램 실행파일(.exe)를 실행시키면 주기억장치인 메모리로 전송되어 (인출)
CPU가 필요한 작업을 할 수 있도록 준비한다 (적재)

그 후엔 사용자가 필요로하는 작업이 어떤 것인지 CPU가 해석하게 되고 (해석)
적당한 작업을 실행하게 된다 (실행)


2.메모장으로 HelloWorld 컴파일및 실행을 하세요.(이번에 외웁시다)

public class HelloWorld {
	public static void main(String[] args) {
		System.out.print("Hello World");
	}
}


3.컴파일 과정이 필요한 이유는?

소스파일을 CPU가 이해할 수 있는 2진법으로 변환하는 과정
class파일을 생성하기 위해



4.메모장으로 아래의 프로그램을 작성하시오.(println 함수만 사용 할것)

원주율 * 반지름의 제곱

= 3.14 * 10 * 10

-반지름의 길이가 10인 넓이를 구하시오.출력은 아래와 같이 나올것

    반지름이 10인 원 넓이는 314 입니다.



public class Circle {
	public static void main(String[] args) {
		System.out.println("반지름의 넓이가 10인 원의 넓이를 구하시오");
		System.out.println("반지름이 10인 원의 넓이는 314 입니다");
	}
}

------------------------------------------------------------------------------------------------------------------------------- 이건 유머라고 함

public class Area {
		public static void main(String[] args) {
			System.out.println("반지름의 길이가 10인 원의 넓이를 구하시오");
			System.out.println("반지름이 10인 원의 넓이는"  + 3.14 * 10 * 10 + "입니다");
		}
	}



*변수 설정 팁

가로x세로

가로*세로 = 넓이

int horizontal = 10;
int vertical = 20;
int area = horizontal*vertical;



5.메모장으로 아래의 프로그램을 작성하시오.(변수 할용 하여..)

-사각형의  넓이를 구하시오. 가로 10 , 세로 20

     사각형의 넓이는 200 입니다.


public class square {
	public static void main(String[] args) {
		
		int num1;
		num1 = 10;

		int num2;
		num2 = 20;

		int num3;
		num3 = num1 * num2;
										
			System.out.println("사각형의 넓이를 구하시오 가로 10 세로 20");
			System.out.println("사각형의 넓이는 200입니다");
			System.out.println(num1 + "x" + num2 + "=" + num3); 
	}
}


------------------------------------------------------------------------------------------------------- 수정본

나름 정답
public class Area {
	public static void main(String[] args) {
		
		int num1;
		num1 = 10;

		int num2;
		num2 = 20;

		int num3;
		num3 = num1 * num2;
										
			System.out.println("사각형의 넓이를 구하시오 가로 10 세로 20");
			System.out.println("사각형의 넓이는" + num3 + "입니다");
			System.out.println(num1 + "x" + num2 + "=" + num3); 
	}
}


6. 아래의 용어를 설명하시오.

변수 선언: 할당된 변수명을 메모리로 입력 시키는 것 

변수: 프로그래밍 작업 시 개발자가 만드는 임의의 "형" type

메모리 할당: CPU가 지시된 변수 작업을 할 수 있게 메모리 할당을 해주는 것

-------------------------------------------------------------------------------------------첫날 연습문제 끝

2020-05-11
어제의 나보다 더 나은 오늘의 내가 되자!
 
프로그래밍은 암기부터 하고 이해해야한다. 외우라는건 외우자.
 
운영체제 OS Operating System 운영체제는 모든 하드웨어와 모든 소프트웨어를 관리하는 컴퓨터시스템의 한 부분인 “실행 관리자”라고 정의할 수 있다. 
운영체제는 누가 시스템을 사용할 수 있고, 어떻게 사용할 수 있는지를 관리하므로, 즉 운영체제는 컴퓨터시스템을 관리하는 보스(boss)라고 할 수 있다.
[네이버 지식백과] 운영체제 [Operating System] (학문명백과 : 공학, 김태달)
프로그램과 응용어플리케이션을 구동하기 위해 운영체제가 존재한다.
ex)
리눅스
macOS
유닉스 계열의 Solaris
Windows x86   , window x64      -> x86= 32bit 옛날 486 586버젼             x64 = 64bit     둘을 나누는 기준 = CPU 차이(Central Processing Unit)  연산장치 , 중앙 처리 장치
그러므로 OS가 없다면 프로그램 구동이 불가능하다.
 
컴퓨터의 구성요소
본체 프레임
메모리 (주기억장치)  -> 개발자에게 중요하다 -> 프로그램은 메모리와의 싸움이다.             보조기억장치 = HDD하드디스크 , SSD(Solid State Drive)
메인보드
그래픽카드 GP         요즘은 게임프로그램 연산처리를 위해 GPU도 나온다.
CPU 연산장치, 중앙처리장치 -> 그러므로 1+1이런건 CPU가 한다.  ->Intel사 와 AMD사가 만든다. -> 세계 4대 발명품 중 한가지. -> 미국은 google, facebook, 테슬라 등등 IT강국
 
이클립스
src = source code 약자
public static void main 암기
 
 
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
 
 
 
 
2020-05-12
 
윤성우의 열혈 JAVA 프로그래밍 2~3번 반복적으로 공부하면 베스트?
HelloWorld 코딩 찍는거 외워야함.
 
JDK= Java Development toolKit
JVM= Java Virtual Machine
 
Oracle 회사는 DataBase 회사.
Google, Facebook은 인터넷 회사.
 
세계 1위 SW 회사 MS
2위는 Oracle
 
FaceBook이나 Google은 인터넷회사이다.
 
프로그램->OS->메모리->CPU
엑셀 프로그램을 실행하는 원리
엑셀의 실행파일인 .exe 파일(.exe 파일은 windows의 실행파일명, MAC은 다르다. 리눅스도 다르다.)을 실행한다.
.exe는 하드디스크에 저장되어있다.(HDD 나 플래시 메모리인 SSD 이것의 명칭은 보조기억장치.)
프로그램 설치라는 것은 하드웨어 위에 해당 프로그램을 저장하는 일이다.
 
.exe파일을 더블클릭하면 OS가 엑셀프로그램을 메모리(주기억장치)로 쭉 올린다. -> 메모리에서 CPU와 통신을 해서 구동
 
그런데 많은 프로그램을 킨다면? 작업관리자에 보면 20개의 프로그램은 돌린다.
프로그램 순서가 메모리 내에서 뒤바뀌면 안되기 때문에 OS가 메모리내에 있는 주소 관리를 한다. (핵심 = 메모리에는 주소가 있다.)
 
class HelloWorld{
public static void main(String [] args){
System.out.println("HelloWorld");
}
}
 
 
 
로컬디스크 D에 HelloWorld.java를 만들고 명령 프롬프트로 javac HelloWorld.java   (javac = java compile의 약자) 
해당 자바파일을 컴파일하면 HelloWorld.class라는 클래스 파일이 생기는데 실행할때는 java HelloWorld      .class(클래스 파일)가 있는 해당 파일명을 입력해서 실행한다.
---->>>>소스파일(.java)를 javac(컴파일)해서 클래스파일(.class 바이트코드)로 변환,생성했다.
왜? 그냥 .java 프로그램으로 실행을 하지 않고 클래스파일로 변경해서 실행할까?????
프로그램->OS->메모리->CPU 
내가 프로그램을 짜려고 class HelloWorld{public static void main~~~~를 친걸 CPU가JVM이 연산을 해서 뿌려줘야되는데 사람말을 못 알아먹는다. 그래서 2진수로 바꿔줘야 한다. digit(숫자라는 뜻)
그래서 우리가 쓴 text 와 10진수들을 0101010덩어리인 2진수로 바꿔주는 역할을 컴파일러(compile 기계어로 번역하다라는 뜻)가 해주는 것이다. 컴파일러의 역할 첫번째, java프로그램을 .class파일로 변환시켜주고
 두번째, 내가 지정한 폴더에 저장시킨다. .exe파일과 .class 동일한 느낌.
결국 프로그램 실행은 .class 파일로 실행한다.
class파일을 OS가 메모리에 쭉 올리고 CPU가 연산하여 실행한다.
 
워드에다가 편지를 쓰다가 컴퓨터를 그냥 종료시키면 사라진다.
그러므로 저장을 해야하는데 저장이란 보조기억장치(HDD, SSD)에 저장해야 한다.
ABCD 등 적어놓은 문자를 010100덩어리 2진수로 바꿔서 저장하는데 CD롬으로 보면 CD롬의 뒷면에 홈이 파져있으면 0 안 파져있으면 1 이런 식으로 레이저로 지져서 저장한다.
하드디스크도 동그란데 간단한 이야기로 한번 긁으면 0 안긁으면 1 
 
이클립스 이용시 .class 파일이 저장되어있는 곳 찾는 방법은 이클립스 좌측 프로젝트명을 우클릭하고 쇼인에서 프로젝트 익스플로러를 누르면 프로젝트별로 저장된 폴더가 나온다.
bin 은 binary의 약자(뜻은 숫자2)컴퓨터가 알아먹는 파일같은 경우(.class)는 bin폴더 안에 있다. 
 
클래스명은 첫글자는 무조건 영문대문자 만약에 소문자로 치면 선배한테 갈굼당한다. 진짜다. 소문자 적어도 에러는 안 난다.
 
자바 프로그램은 반드시 클래스명으로 시작한다. public static void main(String[] args){       중에 JVM이 main(String[] args) 메인함수부터 찾아서 실행한다. 
함수 옆에는 ()가 있다.함수 =method 영어로 method 매서드.
 
class HelloWorld{
public static void main(String [] args){
System.out.println("HelloWorld");
}
}
클래스 안에는 매서드, 그러니까 함수가 올 수 있다. 객체지향언어는 클래스 밖에는 함수가 절대 올 수 없다.
적어놓은건 Class명이 제일 우선이지만 CPU가 직접 실행하는건 main 함수부터 실행한다.
 
System.out.println(" "+ 3 + 8);    ->38                      "" 는 문자열이라 표현하고  ''는 문자라고 표현한다.
System.out.println(3 + 8 + " ");   ->11                      "" 전 숫자는 숫자로 생각하지만 ""문자열 후의 숫자는 문자로 표현한다.
 
주석 /*       */           컴파일러가 주석있는것은 쏙 빼버리고 컴파일해서 클라스 파일로 변환되지 않아서 실행되지 않음.
방법은 두가지 /* */    여러문장 주석  ,  // 한문장 주석.
 
원하는 범위를 잡아놓고 Ctrl + Shift + / : 블록을 주석으로 처리 (/*  */)
주석해제 Ctrl + Shift + \
Ctrl + / 원하는 줄 주석으로처리
 
들여쓰기 늘 주의하라. 옥상 끌려간다.
//////////////////////////////////////////////////////////////////////////////////////////////             1강 끝 ////////////////////////////////////////////////////////////////////////////////////////////////
 
모르면 외우는게 맞지만 이해가 안된다 싶으면 동영상으로 공부하라
 
int num;             //변수 선언declare      ;은 마침표 한 줄 코딩했다는 뜻.
num = 10;
Syso(num);
 
int 는 type , 변수 자료형이라고 한다. type 은 총 8개.  integer  =정수라는 뜻
num 은 변수명이다.
 
int num 선언시   int  = 4byte =32bit  선언하면 주기억장치인 메모리에 4byte의 공간을 num이라는이름으로 방잡아라= (메모리 할당Assign)하라고 함. = 선언. 공간이름이 num 방이름이 num
 
1 + 2 = 3                       =   -> 같다     가       아니라         num = 10;           10을 왼쪽에 대입하라.       32bit = 4byte 짜리 메모리에 00000000~1010 이라는 2진수로 메모리를 할당.
int num;
num = 10;
int num = 12;  하면 오류남    선언은 한번만 해주면 된다.
 
println(num)을 하면 num에 있는 Value 가 출력된다!
 
int num;
num = 10;
num = 20;
Syso(num);
을 컴파일하면      20이 출력된다.            처음에 10먼저 메모리에 할당assign하고 그 다음에 20이 할당되기 때문, 변수라고 표현하는 이유는 값이 변할 수 있기 때문!!!!!!!!!!!! 
10과 20의 값 두개가 할당되는게 아니라  10 위에 20의 값이 덮어씌워지는 것이다.
int num3 = num1 + num2       ->>    int num3 변수부터 선언하고 num1 + num2 수를 더하고    = 대입한다.        1->3->2 순서대로.
 
메모리에는 주소가 있다. num1을 할당하면 num1에 해당하는 주소가 생긴다. 메모리 할당, 메모리 순서 관리도 OS가 한다. OS의 핵심 업무 중 하나. 그래서 우리가 신경쓰지 않아도 됨.
 
 
 
 
면접 족보
1.일반 프로그램이 (옆의 하드웨어 용어를 사용하여) 실행 되는 원리를 설명하시오.(CPU,메모리,HDD )
-일반 프로그램을 실행하는 원리
실행파일인 .exe 파일(.exe 파일은 windows의 실행명, MAC은 다르다. 리눅스는 다르다.)을 실행한다.
.exe는 하드디스크에 저장되어있다.(HDD 나 SSD 이것의 명칭은 보조기억장치.)
.exe파일을 실행하면 OS가 프로그램을 메모리(주기억장치)로 쭉 올린다. -> 메모리에서 CPU와 통신을 해서 구동
 
 
 
2.메모장으로 HelloWorld 컴파일및 실행을 하세요.(이번에 외웁시다) 클라스명과 파일명이 동일해야지 정확히 실행됨. javac로 컴파일 후 java로 실행.
class HelloWorld{
	public static void main(String[]args){
		System.out.println("HelloWorld");
}
}
 
 
 
3.컴파일 과정이 필요한 이유는?
-프로그램->OS->메모리->CPU 
내가 프로그램을 짜려고 친 사람의 말을 CPU나 JVM이 연산을 해서 뿌려줘야되는데 사람말을 못 알아먹는다. 
그래서 기계어인 2진수로 바꿔줘야 한다.
우리가 쓴 text 와 10진수들을 0101010덩어리인 2진수로 바꿔주는 역할을 컴파일러가 해주는 것이다. 
컴파일러의 역할 첫번째, java프로그램을 .class파일로 변환시켜주고 두번째, 내가 지정한 폴더에 저장시킨다.
결국 프로그램 실행은 .class 파일로 실행한다.
class파일을 OS가 메모리에 쭉 올리고 CPU가 연산하여 실행한다.
 
 
4.메모장으로 아래의 프로그램을 작성하시오.(println 함수만 사용 할것)
-반지름의 길이가 10인 넓이를 구하시오.출력은 아래와 같이 나올것
    반지름이 10인 원 넓이는 314 입니다.
 
변수 사용버젼
class Area {
	public static void main(String[]args) {
		int length =10;
		double area = length*length*3.14;
		
		System.out.println("반지름이 " +length+ "인 원의 넓이는 " + area+ " 입니다");
	
		
	}
 
}
 
println만 사용버젼
class Area {
	public static void main(String[]args) {
		
		System.out.println("반지름의 길이가 10인 원 넓이는 "+10*10*3.14+  " 입니다.");
	
		
	}
 
}
 
 
 
5.메모장으로 아래의 프로그램을 작성하시오.(변수 활용하여..)                              ㅡ>>>프로그래밍은 다른거 없다.변수 선언해서 해당 변수의 값만 바꿔서 출력하는게 다이다.
-사각형의  넓이를 구하시오. 가로 10 , 세로 20                                               ㅡ>>>손가락부터 나가지말고 어떻게 할지 머리로 설계부터 하고 진행하자.
     사각형의 넓이는 200 입니다.
class Area {
	public static void main(String[]args) {
		int horizontal =10;
		int vertical =20;
		int area = horizontal*vertical;
		
		System.out.println("사각형의 넓이는 " +area+ " 입니다");
	
		
	}
 
}
 
 
6. 아래의 용어를 설명하시오.
변수 선언: 변수를 선언하면 변수자료형의 크기만큼의 용량크기를 메모리에 할당한다.
변수: 값이 변하는 수 변수자료형의 종류는 8가지이다.
메모리 할당: 변수의 이름과 변수의 자료형을 정하여 선언하면 OS(운영체제)가 자료형만큼의 용량을 정해진 변수명에게 할당한다.
 


ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
 
2020-05-13
 
형 종류는 크게 기본형하고 참조형(메모리에는 주소가 있다. 주소형)(reference)으로 나뉜다.
자바에서 기본적으로 제공하는 자료형인 기본자료형(Primitive Data)은 8가지가 있다.
 
자연수는  1,2,3,4,5
정수는  +가 붙은 양수, -가 붙은 음수, 0
실수는 정수 아닌것. 1.1 소수점 붙은 것
 
boolean 1 char 2 byte 1 short 2 int 4 long 8 float 4 double 8
 
1km= 1000m
1byte = 8bit
 
1byte= 8bit 8개의 방   최대값= 11111111-> 하지만 제일 앞 비트는 양수 또는 음수로 비트를 주게 되면
-128~127의 값을 갖게 된다. 맨 앞자리 비트가 0이면 양수, 1이면 음수.
 
int형은 4byte = 32bit = -21억~21억까지의 숫자 표현 가능 -> 42억개 ->반드시 외워야하는 이유 해당 크기를 벗어나는 실수를 많이 하기 때문에. ->큰 프로그램에서 작은 오차는 더 민감하다.
강사님께서 겪은 에러의 80% int num1 = num2 + num3 = 22억 + 40억 = 62억 int로 해결되지 않는다. 이런 실수들이 크다. 

*변수의 이름을 짓는데 있어 제약사항*

1. 자바는 대소문자를 구분한다
컴파일러는 대소문자까지 다른 형으로 인식한다고 한다
ex) area, Area 각각 다른 방으로 메모리를 부여한다

2. 변수의 이름은 숫자로 시작할 수 없다
ex) 0area 안됨

3. $와 _이외의 특수문자는 변수에 사용할 수 없다
ex) $area, ar_ea 가능
나머지는 불가능

4. 키워드는 변수의 이름으로 사용할 수 없다
컴파일러가 이미 지정해놓은 키워드는 변수로 할 수 없다는말
ex) int변수와 같은 int변수명은 사용 불가


02-2 정수의 표현방식 이해하기

0      0011001
부호  데이터 크기

컴퓨터에서는 음의 정수를 다른 방법으로 표현
*음의 정수를 표현하는 방법

보수란? 
10진수에서 0이 되는 걸 말함
ex) 9의 보수 1
    8의 보수 2
    5의 보수 5

2의 보수법
해당 양의 정수에 1의 보수를 더함 
그리고 1을 더함

모든 자연수의 0제곱은 1


02-3 실수의 표현방식 이해하기

실수는 무한하기 때문에 오차없이 표현이 불가능(메모리는 한정 되어있기때문에)
고정소수점 방법 0.1234, 1.1234
부동소수점 방법 지수와 가수로 나타내는 방법

실수 표현 방법의 기준 [IEEE 754]

02-4 자바의 기본 자료형

byte 1바이트 short 2바이트 int 4바이트 long 8바이트
변수의 자료형 결정은 "해당 변수에 값을 저장 및 참조하는 방식의 결정"을 의미한다

*정수형 덧셈시에는 자료형에 상관없이 int형 덧셈을 진행한다

float 4바이트
.소수점 6자리까지 정밀도 보장

double 8바이트
.소수점 12자리까지 정밀도 보장

*플롯과 더블의 자료형 선택 기준은 정밀도임!
실수같은 경우는 웬만하면 더블로 진행하는게 좋음 (표현 범위가 더 크기 때문에)


※유니코드란?

컴퓨터상에서 문자를 표현하기 위해 전세계에서 규약한 코드 (아스키코드) 1960년대
*블랭크도 문자로 표현 (32번) 아스키코드는 총 127개

아스키코드를 바탕으로 여러 나라의 언어를 표현하기 위해 많은 코드들이 생김
그중 하나가 유니코드임
(인터넷에서는 UTF-8코드로 통일 / 자바는 유니코드로 통일)

03-1 상수

변하게 하지 않는게 상수!
변수에 값을 딱 한 번만 할당할 수 있으면 그것은 상수!
한 번 할당된 값은 변경이 불가능하다
키워드 final 선언이 붙어있는 변수
ex) final nt MAX_SIZE = 100;

*상수의 이름은 모두 대문자로 짓는 것이 관례 (안지키면 옥상간다)
 이름이 둘 이상의 단어로 이뤄질 경우 단어를 언더바로 연결하는 것이 관례 (이것도 옥상 행)
그럼 어떠한 경우에 상수를 쓸까?
값이 변하면 안되는 값에 상수를 쓴다
ex) 원주율 3.14

리터럴
변수명을 지정하지 않고 데이터를 넣는게 리터럴
정수형 리터럴, 실수형 리터럴

long형 상수 표현방법은
기본적으로 CPU는 int 상수로 받아들이기 때문에 42억이 넘는 데이터는 l이나 L을 붙여서 long변수로 인식을 시켜줘야 한다
실수형 상수(리터럴) 삽입을 표현하기 위해 D나 F를 추가할 수 있다

실수형 상수의 e표기법
ex) 3.4e3 를 바꾸면 3.4 x 10의 3제곱 = 3400.0
    3.4e-3 를 바꾸면 3.4 x 10의 마이너스3제곱 = 0.0034

※컴퓨터에서는 제곱 폰트가 없기 때문에 e로 표현하기로 했음

부울형 상수 
참 거짓

문자형 상수
한 글 A Z

변수 8가지
논리형 boolean 1byte true ,false
문자형 char 2byte

정수형
byte 1byte
short 2byte
int 4byte 
long 8byte

실수형
float 4byte
double 8byte


03-2 형 변환
CPU Central Processing Unit 중앙처리장치    , 연산장치 
2 4  8 16 32 64 128 256 512
8      0.1  2 .8

32bit    0.1   2.32

64bit    0.1   2 64 얘가 더 좋음



면접족보 2020-05-13 

1. 기본형 8가지를 말하시오.

논리형
Boolean 1byte
문자형
char 2byte

정수형
byte 1byte
short 2byte
int 4byte
long 8byte

실수형
float 4byte
double 8byte

2.int 형에 들어 갈수 있는 정수의 범위는?
int는 4byte 비트로 환산하면 32비트 그러므로 2의 32제곱 
-21억~+21억 대략 42억정도!


3.2의 보수법이란 ?
2진법을 사용하는 CPU의 특성상 0과 1로 음수, 양수를 구분해야 하는데
음수를 표현할때 활용하는 방법이 바로 2의 보수법이다


4.실수에서 오차가 생길수 밖에 없는 이유는?
실수란 무한대여서 유한한 컴퓨터 메모리로는 정확하게 값을 도출하는게 불가능하다
그래서 대략적인 범위를 정해놓고 값을 구한다

float 4byte 소수점 4자리까지 
double 8byte 소수점 8자리까지


5. 아래의 프로그램을 작성하시오.

-반지름이 7인 원의 넓이 구하기

public class CircleRadius {
	public static void main(String[] args) {
		double radius; 
		double area;
		final double PI = 3.14;
		
		radius = 7;
		area = radius * radius * PI;
		

		System.out.println("반지름이" + radius + "인 원의 넓이는" + area + "입니다");
	}
} 		 







6.아스키코드에 대하여 설명하시오.
자바프로그래밍 안에서 문자를 표현하기 위해 1960년대 미국에서 시작해 전세계에서 규약한 문자열 코드

7.상수란 무엇인며, 자바에서 상수 선언 방법은?
상수란 변하지 않는 변수를 말하며 final 함수를 표시하여 선언할 수 있다 대표적인 예는 원주율


8.아래의 삼각형의 넓이를 구하는 프로그램을 작성하시오.

밑변 * 높이 / 2 = 삼각형의 넓이

-밑변 4.9

-높이 2

public class TriangleWidth {

	public static void main(String[] args) {
		double base;
		double height; 
		double area;
		
		base = 4.9;
		height = 2;
		area = base * height / 2;
		

		System.out.println("밑변이" + base + "이고 높이가" + height + "인 삼각형의 넓이는" + area + "입니다");
	}
}

-----------------------------------------------------------------------------------------------------------------------------------------------

2020-05-14

30-2 형 변환

형변환이란?
변수또는 상수의 타입을 변환하는 것
(타입) 피 연산자
ex) (int) num1

그렇다면?
1. 형변환은 언제 일어나는가?
데이터를 대입시에 타입이 다를때!
- 타입이 다를때
- 대입
- 연산

2. 형변환 법칙
표현할 수 있는 범위가 더 큰 타입으로 바뀌게 된다(자동형변환)
개발자 임의로 형변환을 부여할 수도 있다(명시적 형변환)

규칙1 자료형의 크기가 큰 방향으로 형 변환이 일어난다
규칙2 자료형의 크게에 상관없이 정수 자료형보다 실수 자료형이 우선한다

3. 형변환 종류
자동 형변환
명시적 형변환

*JVM 자바는 기본적으로 32비트로 운영된다
인트보다 작은 변수값이 연산 되더라도
하드웨어의 특성상 32비트로 연산되어지기 때문에 인트 결과값이 나오게 된다
(선이 32개라 32개를 다 안쓰더라도 하드웨어는 32줄을 다 쓰게 된다)
상식적으로 생각하면 안되고 하드웨어의 특성으로 생각을 해야한다

인간 : 이번 작업은 20개만 필요하니까 12개는 안써도 되겠다
하드웨어 : 나는 줄을 줄여서 작업하진 못해 줄이 적은 작업도 32개를 다 쓸래

04-1 자바에서 제공하는 이항 연산자들

= 결합방항 ←
+ 결합방항 ←
- 결합방항 ←
* 결합방항 ←
/ 결합방항 ←
% 결합방항 ←

관계연산자
== 같은가?
!= 다른가?
컴퓨터에서는 이렇게 표현한다

논리연산자
&& AND 둘다 포함 되어야 해
CPU는 둘다 연산한다

|| OR 둘중 하나만 인정되면 오케이
둘중 하나만 맞으면 연산을 멈춘다

! NOT 이거 헷갈린다 
이 강아지가 푸들이 아닌가?
맞으면 false 틀리면 true


04-2
자바에서 제공하는 단항 연산자들

-연산자는 "-" 연산자 붙이기

증가감소 연산자
전위 연산자
ex) num = ++num 내부에서 +연산된 값이 바로 출력되어 진다
    num = --num 내부에서 -연산된 값이 바로 출력되어 진다

후위 연산자
ex) num = num++ 일단 본래 데이터가 출력되어진 후 (세미콜론 뒤에 플러스 되어 있다가) 다음 값 출력시에 적용되어 나타난다
    num = num-- 일단 본래 데이터가 출력되어진 후 (세미콜론 뒤에 마이너스 되어 있다가) 다음 값 출력시에 적용되어 나타난다

04-3
비트를 대상으로 하는 연산자들

*비트연산자 
& | ^ ~

&. 비트 단위로 AND연산을 한다 
둘다 참일때만!  1을 참으로 0을 거짓으로 본다
A B A&B
1 1   1
1 0   0
0 1   0
0 0   0

|. 비트 단위로 OR연산을 한다
둘 중 하나만 참이어도 참으로 본다
A B A|B
1 1   1
1 0   1
0 1   1
0 0   0

^. 비트 단위로 XOR연산을 한다
같은 값을 거짓으로 본다
A B A^B
1 1   0
1 0   1
0 1   1
0 0   0

~. 비트 단위로 NOT연산을 한다
참이던 거짓이던 결과 값 반대로 연산을 한다
1 0
0 1

비트 쉬프트 연산자
<<. 이진법으로 본 상태에서 각 비트열의 값을 왼쪽으로 이동시킨다
결과적으로 값이 2배씩 커진다
>>. 이진법으로 본 상태에서 각 비트열의 값을 오른쪽으로 이동시킨다
결과적으로 값이 2로 나눈 값으로 정해진다
음수인 경우에는?
맨 앞의 음수 부호는 보존해주고 수행한다


2020-05-14 면접족보

1.형변환이란
서로다른 타입의 데이터에서 연산이 필요할 때
사람과 달리 컴퓨터 CPU는 서로 같은 타입의 형만 연산을 할 수 있기 때문에
연산을 진행하기 위해 형(TYPE)를 변환 하는 것


2.형 변환 종류에 대하여 설명하시오.
자동 형 변환 
자바 프로그램 내에서 연산을 처리하기 위해 개발자의 임의적인 형 변환을 거치지 않고 자동으로 형을 변환해 연산을 처리하는 것

명시적 형 변환
자바 프로그램 내에서 자동으로 처리되어 지는 형 변환 이외로 개발자의 필요에 따라 특정한 값을 얻고자 할때 
강제적으로 원하는 형태로 변환을 시켜 연산을 처리하는 것을 말함


3.형변환은 언제 일어나는가?
1. 데이터의 타입이 다를때
CPU는 서로 같은 타입의 형만 연산을 할 수 있기 때문에

2. 대입시에
형마다 가지고 있는 고유 데이터 크기에 차이가 있으므로 큰 데이터의 형을 보다 작은 데이터의 형에 대입시에는 컴파일 에러가 발생
에러를 해결하고자 형 변환이 필요

3. 연산시에
형마다 표현할 수 있는 수의 크기와 범위가 다를 뿐더러 앞서 말했듯 CPU는 서로 같은 형의 데이터만 연산을 할 수 있기 때문


4.아래의 프로그램을 짜시오.

 -100 이 짝수 이면 짝수 입니다 라고 출력 하는 프로그램을 작성하시오.

public class EvenNumber {

	public static void main(String[] args) {
		int num = 100;
		boolean result;
			result = ((num % 2) == 0);
			
			System.out.println("숫자" + num + "은 짝수일까 홀수일까?" + '\n' + "짝수는 true 홀수는 false로 표기됩니다 " + result);

	}

}

 - 66 이  2의 배수 이고 3의 배수가 맞는지 출력하는 프로그램을 작성하시오.

public class Multiple {

	public static void main(String[] args) {
		int num = 66;
		boolean result;
			result = ((num % 2) == 0) && ((num % 3) == 0);

			System.out.println("숫자" + num + "이 2의 배수이고 3의 배수가 맞을까?" + '\n' + "2와 3의 배수가 둘다 맞을 시에는 true 둘중 하나라도 아닐 시 false " + result);

	}

}

 - 90 과 91 중 큰수를 출력하는 프로그램을 작성하시오.(어려우면 하지 말것)

public class Bigger {

	public static void main(String[] args) {
		
		System.out.println(("90 < 91") + (90 < 91));
		System.out.println(("90 > 91") + (90 > 91));
		
		
	}

}

5. 전위 연산자와 후위 연산자에 대하여 설명하시오.

   -num++ 와 ++num 의 차이

++전위 연산자
CPU가 연산하여 +1 되어진 값이 바로 출력되어 나타난다

++후위 연산자
일단 원래의 데이터가 보여지고 (이미 연산은 +1 되어있음) 후에 나타나는 데이터에 +1이 된 데이터가 출력된다 
괄호에 있는 문장 전체를 실행하고 마지막에 값을 더한다

6. & 와 && 의 차이는 무엇인가?

&은 비트연산자로써 비트 연산자란 각각의 비트를 대상으로 연산을 진행하고 연산되어진 결과를 하나로 묶어서 출력해준다 
&비트 연산자는 AND연산자로 1을 참 0을 거짓으로 보고 둘다 참일때만 연산을 진행한다

&&는 논리연산자로써 bollean 형태에서 쓰이게 된다
AND방식으로 데이터를 연산하게 되며 연산한 값이 모두 true이면 연산 결과또한 true로 출력된다 
하나라도 false가 나오면 true로 표시할 수 없기 때문에 false가 나오면 다음 연산은 생략되어진다


7. -1을 2의 보수법(이진수)으로 표현하시오.

양수 1의 이진법 표기는 00000001 
1의 보수법을 활용해 치환하면 11111110
1을 더한다
11111111
결론 11111111

8. 아래의 출력에 대한 원리를 생각하여 보시오(연산자 우선순위 등을 생각하여).

1. System.out.println("이원의 넓이는 " + 3.14 *10 * 10 + "입니다.");


2. System.out.println("7" + 8 * 9 + 10);

1. 원의 넓이를 구하는 공식을 출력이고 
괄호안에 들어있는 데이터 중 곱셈으로 되어있는 3.14 * 10 * 10 부터 연산을 진행한 다음
앞에있는 문자열 부터 차례로 출력되어진다

결국 도출되는 출력값은 이 원의 넓이는 314 입니다

2. 77210

우선 곱연산 되어있는 8*9를 먼저 계산하게된다 72
그리고 순차적으로 진행
앞의 문자열 7 
772
그다음 앞의 문자열 때문에 문자열로 종속되어버린 상태이기 때문에
+10연산을 하는게 아닌 그냥 10을 붙여버림
그래서 77210


---------------------------------------------------------------------------------------------------------------------------------------


2020-05-15
두형

팔자식 ~ 불린부터 더블까지

주소형 " " 안에 들어가는 애들

05-1 if 그리고 else


1. if문
컴퓨터 상에서 if는 조건문!
참일때는 값이 나오지만 거짓일때는 출력되지 않는다
if문 뒤에는 무조건 조건이 나와야 한다
ex)
if(n1 < n2) {
System.out.println("n1 > n2 is true");
}
*한줄짜리 조건문은 중괄호 생략 가능

2. if~else문
두개의 조건문 중 무조건 하나는 나오게 된다 true일때 false일때
참일때는 true 거짓일때는 false 

*조건을 두개이상 체크해야 할때 if~else 계속 추가 가능
ex)
if 조건
시스템 프린트 블라블라

else if 조건
시스템 프린트 블라블라
(※이때 else if 조건은 내가 원하는 만큼 추가 가능!)

else 조건
시스템 프린트 블라블라

예제문제 
1. 짝수 홀수 구하는 프로그래밍

10이 짝수이면 10은 짝수입니다
11이 홀수이면 홀수입니다

int number = 10; // 이 숫자가 짝수이면 짝수라고 출력
		
		if(number % 2 == 0) {
			System.out.println(number + "이 숫자는 짝수입니다");
		}else {
			System.out.println(number + "이 숫자는 홀수입니다");
		}


2. 나이대 별로 20, 30, 40대 출력하는 프로그래밍

int age = 39; // 나이대 별로 20, 30, 40대라고 출력
		
		if((age >= 20) && (age <=29)) {
			System.out.println(age + "이 사람은 20대 입니다");
		}else if((age >= 30) && (age <= 39)) {
			System.out.println(age + "이 사람은 30대 입니다");
		}else {
			System.out.println(age + "이 사람은 40대 입니다");
		}


3. 이 숫자가 양수인지, 음수인지, 0인지 출력하는 프로그래밍

int number3 = 0; // 이 숫자가 양수인지 음수인지 0인지 출력
		
		if(number3 > 0) {
			System.out.println(number3 + "이 숫자는 양수입니다");
		}
		else if(number3 <0) {
			System.out.println(number3 + "이 숫자는 음수입니다");
		}
		else {
			System.out.println("이 숫자는" + number3 + "입니다");
		}


4. 이 문자가 F이면 여자입니다 M이면 남자입니다

char gender = 'a'; 
		
		if(gender == 'F' || gender == 'f') {
			System.out.println("여자입니다");
		}
		else if(gender == 'M' || gender == 'm') {
			System.out.println("남자입니다");
		}
		else {
			System.out.println("정체성이 모호합니다");
		}


*Syso 컨트롤 스페이스 하면 프린트ln 바로 나옴*


삼항연산자


05-2 Switch와 Break

"걸어서 하늘까지"
"걸리면 브레이크까지"
!브레이크까지임 디폴트까지 아님!


05-3
for while 그리고 do while

1. while문
먼저 조건검사!
그리고 결과가 참이면 중괄호에 있는 영역을 실행한다
반복조건이 참이면 반복영역에 따라 계속 반복한다 
결과값이 거짓이 될때까지 계속된다

2. do~while문

while문과 반대로 끝으로 온다 !그러므로 반드시 do~while문에서는 마지막에 꼭 세미콜론을 찍어야 한다

do문이 반복영역이 되고 while문이 반복조건이 된다
그래서 while과 차이는 참이던 거짓이던 일단 먼저 연산한다

3. for문

판단이 거짓이 될때까지 영역을 계속 반복한다
초기화-조건-반복의 형태로 무한루프 작업을 실행한다

처음 할당된 변수를 초기화 하고 특정 조건을 확인하여 참일 시 작업을 반복하게 된다 
반복 작업을 진행할때 마다 i를 1씩 증감시킵니다

설정했던 조건이 거짓이 나올 시 루프에서 탈출합니다

i = 0일때 1-2-3-4
i = 1일때 2-3-4
i = 2일때 2-3-4
i = 3일때 2  판단(거짓) 이때 비로소 탈출!

         1        2     4	
for(int i = 0; i < 3; i++) {                    3  
	System.out.println("I love Java" + i);



2020-05-15 연습문제


1. 80 과 90 중 큰수를 출력하는 프로그램을 작성하시오.

int number1 = 80;
		int number2 = 80;
		// 80과 90중 더 큰수를 출력하세요
		if (number1 > number2) {
			System.out.println(number1 + "이" + number2 + "보다 큰수 입니다");
		}
		else if (number1 < number2 ) {
			System.out.println(number2 + "이" + number1 + "보다 큰수 입니다");	
		}
		else {
			System.out.println("두 수는 같아");
		}

2. 국어 70, 수학 60 ,영어 70 의 총점과 평균을 출력하고  (이거는 반드시 외워야 함)
평균에 대한 수우미양가를 출력하는 프로그램을 작성하시오.

public class TotalAverage {

	public static void main(String[] args) {
		/*국어 70, 수학 60 ,영어 70 의 총점과 평균을 출력하고
		평균에 대한 수우미양가를 출력하는 프로그램을 작성하시오.
		*/
		int a = 75;
		int b = 83;
		int c = 92;
		int total = (a + b + c);
		int average = ((a + b + c) /3);
		
		System.out.println("세 과목의 총점은" + total + '\n' + "세 과목의 평균은" + average);
		
		if(average >= 90) {
			System.out.println(average + "수");
		}
			else if(average >= 80) {
				System.out.println(average + "우");
			}
			else if(average >= 70) {
				System.out.println(average + "미");
			}
			else if(average >=60) {
				System.out.println(average + "양");
			}
			else {
				System.out.println(average + "가");
			}
		
	}
	

}

3.변수 3개를 선언후 값을 할당 하여, 3개중 MAX 값을 출력하는 프로그램을 작성하시오. 써도 됌

public class MaxData {

	public static void main(String[] args) {
		// 변수 3개를 선언후 값을 할당 하여, 3개중 MAX 값을 출력하는 프로그램을 작성하시오.
		int num1 = 2;
		int num2 = 1; 
		int num3 = 3;
		
		if((num3 > num1) && (num3 > num2)) {
			System.out.println("셋중에 가장 큰수" + num3);
		}
		else if((num2 > num1) && (num2 > num3)) {
			System.out.println("셋중에 가장 큰수" + num2);
		}
		else if((num1 > num2) && (num1 > num3)) {
			System.out.println("셋중에 가장 큰수" + num1);
		}
		else {
			System.out.println("세 숫자가 다 같다");
		}
	}

}


int a = 10;  //한줄짜리 코딩
		 int b = 20;
		 int c = 30;
		
		 int max = 0;
		 
		 max = (a > b && a > c)? a : (b > c) ? b : c;
		 
		 System.out.println("Max 값은" + max);




4. switch 문의 동작 방식에 대하여 설명하시오.(걸어서 하늘까지)
걸어서 하늘까지와 비슷하게 걸리면 브레이크라고 설명할 수 있다
입력한 특정 값과 부합하는 데이터부터 출력을 시작해 브레이크 설정 지점까지 출력을 하게 된다
디폴트값을 따로 설정하여 부합하는 데이터가 없을 시 출력이 되게 하는 방법을 취할 수도 있다


5. do while 과 while 문의 차이는?
명령 시행 순서에 차이가 있다
while 문은 먼저 값의 참과 거짓을 구분한 뒤 참일때만 설정된 작업을 시행하며 거짓일때는 시행하지 않는다
지정한 반복조건이 거짓이 될때까지 반복영역 작업을 계속한다

do while은 우선 참인지 거짓인지 구분없이(반복영역)을 실행한 다음
반복조건이 참이면 작업 반복을 시작한다
마찬가지로 거짓이 될때까지 작업을 반복한다


6. for 문의 실행 순서를 설명하시오.

판단이 거짓이 될때까지 영역을 계속 반복한다
초기화-조건-반복의 형태로 무한루프 작업을 실행한다

처음 할당된 변수를 초기화 하고 특정 조건을 확인하여 참일 시 작업을 반복하게 된다 
반복 작업을 진행할때 마다 i를 1씩 증감시킵니다

설정했던 조건이 거짓이 나올 시 루프에서 탈출합니다



7.do while 문과 while 문을 이용 하여, 9단을 찍으시오. 구단을 찍어라 

둘다 만들기

while 

public class MultiplicationTable9Dan {

	public static void main(String[] args) {
		int num = 1;
		while(num <= 9) {
			System.out.println("9 X " + num + "=" + (num*9));
			num++;
		}

	}

}

do while

int dan = 1;
		do {
			System.out.println("9 X " + dan + "=" + (dan*9));
			dan++;
		} while(dan <=9); {
			
		}


8.구구단 6단 중 짝수만(6*2, 6*4, 6*6,6*8) 찍으시오.


1번 방법
+= 쓰는 방법

public class MultiplicationTable6Dan {

	public static void main(String[] args) {
		
		int dan = 6;
		
		for(int i = 2; i < 10; i+=2) {
			System.out.println("6X" + i + "=" + (dan * i) );
		}

	}

}


2번 방법
if 추가하기

public class MultiplicationTable6Dan {

	public static void main(String[] args) {
		
		int dan = 6;
		
		for(int i = 1; i < 10; i++) {
			if(i%2==0)
			System.out.println("6X" + i + "=" + (dan * i) );
		}

	}

}

-----------------------------------------------------------------------------------------------------------------

3을 고정시키고

1*
2*
3*
~9*
9반복 for문

5050 1부터 100까지의 합


1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20

2 4 6 8 10 12 14 16 18 20



/* 구구단 구하는 공식
		int dan = 3;
		
		for(int i = 1; i < 10; i++) {
			System.out.println("I love Java" + (dan * i));
		}*/


i++ , ++i
                      i+=2        i+2 = i
1+1 =2 
1*1 =1
1/1 =1
1%1

-----------------------------------------------------------------------------------------------------------

2020-05-18 

05-4 break 와 continue 

1. break 반복문 안에서 빠져나오게 하는 함수
얘는 그냥 빠져나오는 것

2. continue 반목문 안에서 조건검사(처음으로) 가게 하는 함수
얘는 처음으로 점프 하는 것

중요! break는 조건인 while문만 빠져나오는 것!
뒤에 if 까지 빠져나오는게 아님


조건을 달지 않으면 while do while for문은 무한루프를 타게된다
형 범위를 초과하는 범위가 나오면 오버플로우가 됨(정말 다른 값이 들어가게됨)
그럼 엄청난 오차가 발생하기 때문에 항상 범위 지정을 잘 해야 한다!

05-5 반복문의 중첩

3 X 3 = 9가지의 중첩 형태

하지만 거의 for-for형태를 가장 많이 함

여기서 응용 형태인 구구단 전체 과정을 풀이할 수 있음
2단부터~9단까지

첫번째 바깥쪽 for문인 단이 바뀌는 로직을 먼저 생각해야 한다
2-3-4-5-6-7-8-9 이런식으로

두번째 안쪽 for문인 곱 식이 바뀌는 로직을 생각한다
1-2-3-4-5-6-7-8-9 이런식으로

for for를 활용해서 로직을 구현해본다


※구구단 전체를 뿌리는 소스 9단까지
for(int i = 1; i <= 9; i++) {
			
			for(int j= 2; j <= 9; j++) {
			
			System.out.print(j + "*" + i + "=" + (i*j) + "\t");
		
			}
			System.out.println("");
		}


2020-05-18 면접족보

1. 각각의 반복문의 무한 루프를 만드는 방법은?
결과값이 딱 떨어지지 않는 무한 조건검사를 만드는 방법이나
break 조건이나 continue 조건을 달지 않으면 된다


2.구구단을 짜는 프로그램을 작성하시오.(외울것)


public class NewWork {

	public static void main(String[] args) {
		for(int i = 2; i<=9; i++) {
			
			for(int j = 1; j<=9; j++) {
				System.out.print(i + "*" + j + "=" + (i*j) + '\t');
			}
					System.out.println("");
		}

	}

}


3.아래와 같이 프로그램을 짜시오.

*****

 ****

  ***

   **

    *     

public class NewWork {

	public static void main(String[] args) {
		
		for(int i=1; i<=5; i++) {
			
			for(int k=1; k<i; k++) {
				System.out.print(" ");
			}
			
			for(int j = 5; j>=i; j--) {
				System.out.print("*");
			}
				System.out.println("");
		}
		
	}

}


4. 1 부터 100 까지 더하는 프로그램을 작성하시오(외울것)

1+2+3+4+5+......+100;

public class NewWork {

	public static void main(String[] args) {
		
		int sum = 0;
		
		for(int i = 1; i<=100; i++) {
			sum = sum+i;
			
			System.out.println(sum);
		}
		
	}

}


5. 129 Page 문제 2

자연수 1부터 시작해서 모든 홀수를 더해 나간다 그리고 그 합이 언제(몇을 더했을때) 1000을
넘어서는지 그리고 1000을 넘어선 값을 얼마가 되는지 계산하여 출력하는 프로그램을 작성해 보자

public class NewWork {

	public static void main(String[] args) {
		int i;
		int sum = 0;
		
		for(i=1; i<=100; i++) {
			if(i%2==0) {	
			continue;
			}
			sum = sum+i;
			if(sum>1000) {
				break;
			}
			
		}
		System.out.println(i+" "+sum);
	}

}


6. 135 page 문제 1

구구단의 짝수 단인 2, 4, 6, 8단만 출력하는 프로그램을 작성하되 2단은 2x2까지 4단은 4x4까지
6단은 6x6까지 8단은 8x8까지 출력하도록 작성하자
















-진성이답-
public class NewWork {
	public static void main(String[]args) {
		int i;
		int j;
		
		for(i=1;i<10;i++) {
			if(i%2==1) {
				continue;
			}
			System.out.println("["+i+"단]");
			for(j=1;j<=i;j++) {
				System.out.println(i+"X"+j+"="+(i*j));
			}
		}
	}
	

}


7. 125 page - 문제 1

1부터 10까지의 곱의 결과를 출력하는 프로그램을 for문을 이용해서 작성해보자










8. 135 page 문제 2 (선생도 무슨말인지 모르겠음)

다음 식을 만족하는 모든 A와 B의 조합을 구하는 프로그램을 작성하자 
  AB
+BA
------
  99

---------------------------------------------------------------------------------------------

2020-05-19 

06-1 메소드에 대한 이해와 메소드의 정의

메소드?=함수
함수만 할 수 있어도 프로그래밍 짤 수 있다
이말은 뭐다? 함수는 엄청 중요하다!

publilc static void 선언이 의미하는 바는?

*publilc static void main(String[] args)*
자바에서 정한 규칙 : 프로그램의 시작은 main에서부터

메인 다음에 이어지는 중괄호부터는 "바디"라고 표현함

엄밀히 따지면 void부터 함수 시작

함수의 구성 요건

1. 만들어야 한다

2. 만들었으니까 사용할 줄 알아야 한다

즉 만들 수 있어야 하고 사용할 줄 알아야 한다

※만드는것은 중괄호 바디가 있는데
사용하는것은 중괄호 바디가 없다

중괄호 바디가 만든 함수를 사용한다

public static void hiEveryone(int age)
함수 뒤 괄호안에 들어가는 것은 매개변수=파라미터

2번이상 쓰는것은 함수로 활용해야 한다


※함수 기본형

함수선언
바디가 없는 함수!

함수구현
바디가 있는 함수!

A 반환형
B 함수의 이름
C 매개변수
D 값의 반환

  int             Add             (int num1, int num2)
반환형	함수의이름	        매개변수
	{
	      int result = num1 + num2;
                  return result;
                    값의 반환

※void가 붙으면 값 반환을 안하겠다는 뜻이다
리턴값이 없다!

단 void가 붙은 함수에 return을 붙이면 
메소드의 종료를 뜻한다 = 함수 종료 (break와 비슷한듯?)


1. 함수의 구성요소 4가지에 대하여 설명하시오

반환형 함수명 매개변수 리턴값

int Add (int num1, int num2)

int result = num1 + num2;
return result;


2020-05-19 면접족보


1.함수의 구성요소 4가지에 대하여 설명하시오.

int                add         (int num1, int num2)
반환형	    함수이름	매개변수
{

	int re = num1+ num2;

	return re;
	리턴값
}

2. 함수 구현과, 함수 호출의 다른 점은 무엇인가요?

함수 구현

함수의 구성요소를 만들고 필요한 데이터를 얻기위해!
문제처리방법을 소스코드로 묶어놓고 필요에 따라 동작하는 기능

함수 호출
함수 구현에 필요한 데이터값을 메인 함수가 원하는 때에 데이터 중복 없이
가져오는 것 

3. 함수 선언이란?

함수를 활용하기 위해 
반환형 변수 함수이름 매개변수 리턴값을 지정하는 것

4. return 의 두가지 의미는?

메소드를 호출한 영역으로 데이터 반환
메소드의 연산작업 종료


5. 국어, 영어 수학 점수변수 선언후 평균과 합계를 출력하고 수우미양가를 출력하는 프로그램을 작성하시오(외우세요).

average 함수와 grade 함수는 작성해서 호출할것.


package methodHomeWork;

public class MethodHomeWork1 {

	public static void main(String[] args) {
		int kor = 73;
		int eng = 82;
		int meth = 93;
		int total = (kor+eng+meth);
		int average;
		average = totalAvg(kor,eng,meth);
		char grade;
		grade = gradeScore(average);
		System.out.println("국영수 총 합은 " + total + "입니다");
		System.out.println("국영수 평균은 " + average + "입니다");
		System.out.println("국영수 평균 등급은 " + grade + "입니다");
		
	}

	public static int totalAvg(int kor, int eng, int meth) {
		int average = ((kor+eng+meth)/3);
		return average;
	}
	
	public static char gradeScore(int average) {
		char grade;
			if(average >= 90) {
				grade = '수';
			}
			else if(average >= 80) {
				grade = '우';
			}
			else if(average >= 70) {
				grade = '미';
			}
			else if(average >= 60) {
				grade = '양';
			}
			else {
				grade = '가';
			}
		
		return grade;
	}
}


6. 142 page 문제 1 번 2번 .



7. 정수 하나를 입력 받아 아래와 같은 별찍기를 함수를 만드시오.

3을 받으면(3층탑)

*

**

***

4을 입력 받으면(4층탑)

*

**

***

****

8.정수 하나를 입력 받아 입력받은 수가 8이면 1부터8단까지 구구단 출력하는 함수를 작성하시오.


9.정수 하나를 입력받아 1 부터 입력받은 수까지 합을 구하는 함수를 작성하시오.



10.두수를 입력 받아 아래와 같은 함수를 만드시오.

 5 와 10을 입력 받을시

 5+6+7+8+9+10 의 합을 리턴

만약 첫번째 입력값이 두번째 입력값보다 같거나 작을경우

프로그램 에러입니다 출력 하도록 할것.


11. 두수를 입력 받은후 두수의 최소 공배수를 리턴하는 함수를 만드시오. 두수가 같거나 하나라도 음수이면 프로그램 실행 안됨이라고 출력 할것.


12.정수하나를 입력받아 해당 입력받은 수의  구구단 을 출력하시오. 8이면 8단 .. 7이면 7단 .. 


---------------------------------------------------------------------------------------------------------------------------------------------------------------------------


2020-05-20 

06-2 변수의 스코프

각 함수들이 가지는 유효범위가 스코프라고 이해하면 됨
각 영역(중괄호) 안에서만 연산이 이루어지고 그 다음으로 큰 영역으로 갈때는 방을 없앤다
함수포함 모든 코딩을 할때 적용되는 사항이기에 각 함수별 적용 영역을 잘 살펴보자!

영역도 중요하지만 같은 변수명으로 선언을 하면 즉 중복 이런경우도 컴파일 오류가 된다


06-03 메소드의 재귀호출

함수 내에서 자기 자신을 다시 호출하는 것


07-1 클래스의 정의와 인스턴스 생성

클래스가 뭔지 인스턴스가 뭔지

클래스의 기본구성
데이터 : 프로그램에서 유지하고 관리해야 하는 데이터 (변수 또는 상수)
기능 : 데이터를 처리하고 조작하는 기능(함수)=메소드

즉 변수 + 함수는 클래스의 기본구성

인스턴스 변수란?
클래스 내에 선언된 변수
인스턴스 메소드란?
클래스 내에 정의된 메소드

※new의 정의

2형제 	          8자식
기본형
주소형(참조형)

기본형 8개가 아닌것은 다 참조형

변수명→변수선언→메모리할당

BankAccount     yoon                               =                                           new                                         BankAccount();
클래스명	        변수명(주소)	                    대입	                             .class를     	                  클래스명 함수선언(클래스함수)	
참조형	        (yoon이라는              jvm이 관리하는                          메모리에 집어넣어라
	        이름으로 방잡는것)     첫번째 주소를 대입                     =cpu가 읽어들일 수 있게
                                                                                                    =객체생성
함수는 일단 4바이트를 메모리에 할당


인스턴스란?
객체=인스턴스
new란 객체생성

클래스와 인스턴스의 차이는 무엇인가?
붕어빵틀과       붕어빵
.class          인스턴스(객체)

클래스 = 내가 컴파일 .class를 한 것
인스턴스 = 뉴 키워드로 메모리에 올린게 인스턴스(객체)


인스턴스 
---------------------------------------------------------------------------------------------------------------------------------

2020-05-20 면접족보

1. class 란 무엇과 무엇으로 구성되어 있는가?

데이터와 기능으로 구성되어 있다

데이터 : 프로그램에서 유지하고 관리해야 하는 데이터 (변수, 상수)

기능 : 데이터를 조작하고 처리하는 기능 =함수(메소드)


2.아래의 용어를 설명하시오.


인스턴스 변수 

로컬변수




3. 클래스와 인스턴스의 차이는 무엇인가요(붕어빵틀과 붕어빵)?



4. BankAccount yoon = new BankAccount(); 의 메모리를 그리시오.


5.아래 프로그램의 출력결과를 예측하고,메모리그림으로 설명하시오.



public class BankAccount {

	int account = 0;

}



public class BankAccountOO {



	public static void check(BankAccount bank) {

		

		System.out.println(bank);

		System.out.println(bank.account);

		

		bank.account = 90;

		

	}

	public static void main(String[] args) {

		// TODO Auto-generated method stub

		BankAccount yoon = new BankAccount();

		

		yoon.account = 10; //옥상 올라감.

		

		System.out.println(yoon);

		System.out.println(yoon.account);				

		

		check(yoon);

		

		System.out.println(yoon.account);		

	}



}



6.1. 클래스 이름 : Triangle 

     -인스턴스 변수 : width,height

     - 삼각형의 넓이를 구하는 함수 : getArea

     - 변수 셋팅 함수고,  Test 클래스에서

 테스트 하시오.

함수부분 (인스턴스)

package Triangle;

public class Triangle {
	int width; //인스턴스 변수
	int height; //인스턴스 변수
	
	void setWidth(int w) { //setter 함수
		width = w;
	}
	
	void setHeight(int h) { //setter 함수
		height = h;
	}
	
	int getArea() {
		int area = width * height /2;
		return area;
	}
	
}


클래스부분 (테스트)

package Triangle;

public class Test {

	public static void main(String[] args) { //클래스변수
		
		Triangle triangleWidth = new Triangle();
		
		triangleWidth.setWidth(10);
		triangleWidth.setHeight(10);
		
		System.out.println("이 삼각형의 넓이는 "+triangleWidth.getArea());

	}

}





7. 클래스 이름 : Student 

     -인스턴스 변수 : kor, eng, math

     -setter 함수 작성 

     - grade 함수 average 함수 작성

     Test 클래스에서 평균과 수우미양가를 출력하는 프로그램을 작성하시오.


함수부분 (인스턴스)

package Studant;

public class Studant {
	double kor; //인스턴스 변수
	double eng; //인스턴스 변수
	double math; //인스턴스 변수
	double average; //인스턴스 변수
	
	void setKor(int k) {
		kor = k;
	}
	void setEng(int e) {
		eng = e;
	}
	void setMath(int m) {
		math = m;
	}
	double getAverage() {
		average = (kor+eng+math)/3;
		return average;
	}
	
	char getGrade() {
		char grade;
			if(average >= 90) {
				grade = '수';
			}
			else if(average >= 80) {
				grade = '우';
			}
			else if(average >= 70) {
				grade = '미';
			}
			else if(average >= 60) {
				grade = '양';
			}
			else {
				grade = '가';
			}
			return grade;
	}
}


클래스부분 (테스트)

package Studant;

public class Test {

	public static void main(String[] args) { //클래스 변수
		
		Studant record = new Studant();
		
		record.setKor(90);
		record.setEng(90);
		record.setMath(90);
		
		System.out.println("이 학생의 평균은"+record.getAverage()+"입니다.");
		System.out.println("이 학생의 등급은"+" "+record.getGrade()+" "+"입니다.");
	}

}




8.재귀함수란 무엇인가?

----------------------------------------------------------------------------------------------------------------------

2020-05-21 

참조변수에 null대입

null을 대입하면 jvm이 개입하여 메모리 관계를 끊는다
참조변수가 참조하는 인스턴스와 관계를 끊는다

07-2 생성자와 String 클래스의 소개

문자열을 메소드의 인자로 전달할때 사용된다
String형 참조변수를 선언하여 문자열을 인자로 전달받는다

생성자란?
함수이름이 클래스 이름과 같은걸 생성자라고 한다

(자신이 가지고 있는 인스턴스 변수 초기화)
생성자는 리턴값이 없는게 특징

디폴트생성자
생성자를 개발자가 지정해 놓지 않았을때 컴파일러가 자동으로 생성자를 넣어주는데 이게 디폴트생성자


07-3 자바의 이름 규칙

클래스 이름의 첫자는 꼭 대문자로 작성한다
둘이상의 단어가 묶여질때는 이어지는 첫 글자를 대문자로 작성해야한다

메소드 및 변수의 첫 글자는 소문자로 작성한다 
이것 역시 둘 이상의 단어가 묶여질때는 이어지는 첫 글자를 대문자로 작성해야 한다

상수는 모든 문자를 대문자로 작성하여야 한다
둘이상의 단어가 묶여질때에는 단어 사이를 언더바로 표기한다


2020-05-21 면접족보


1. JVM에 대하여 설명하시오(인터넷 찾아 볼것).

JVM이란 Java Virtual Machine 의 줄임말이며 Java Byte Code를 OS(운영체제)에 맞게 해석해주는 역할을 합니다
Java compiler는 .Java파일을 .class라는 Java Byte code로 변환시켜줍니다

Byte Code는 기계어가 아니기 때문에 OS에서 바로 실행되지 않습니다
이때! JVM은 OS가 ByteCode를 이해할 수 있도록 해석 해줍니다

https://articles09.tistory.com/36 
집가서 또 정리

2.생성자란 무엇이며, 용도는?

프로그램을 만들때는 변수를 선언하고 반드시 초기화를 해주어야 한다
만약 하지 않는다면? 해당 변수에는 쓰레기값이 들어가게 되고 심한경우 초기화 오류 발생!

그래서 변수의 초기화를 진행하는 프로세스를 클래스에 대입한 개념으로 
객체를 호출할때 클래스는 생성자를 통해 객체를 초기화 하게 되는데
구현 방법에 따라

1.기본생성자
2.묵시적생성자
3.명시적생성자로 나뉘게 된다

https://m.blog.naver.com/PostView.nhn?blogId=yun4794&logNo=221110665473&proxyReferer=https:%2F%2Fwww.google.com%2F

자세한 사항 집에서 정리

3.디폴트 생성자란 무엇인가?

디폴트 생성자란 클래스 내부에 어떠한 생성자도 없을 시 객체 생성 과정에서
컴파일러가 자동으로 추가하는 생성자다

의미도 없는 기본 생성자를 선언해 주느냐 함은!
클래스에 생성자가 없으면 객체에 접근 자체를 하지 못하기 때문이다

https://m.blog.naver.com/PostView.nhn?blogId=yun4794&logNo=221110665473&proxyReferer=https:%2F%2Fwww.google.com%2F

자세한 사항 집에서 정리

4.Cammel case 에 대하여 설명하시오.

카멜케이스가 생겨난 이유는 컴퓨터는 띄어쓰기를 인식하지 못하기 때문입니다
대부분의 프로그래밍에서 띄어쓰기란 다른 문법이나 옵션을 사용할 때이기 때문에
이름을 지을때 사람이 읽기 힘들게 되었습니다

특히 두종류의 단어가 연이서 써진경우 읽기가 힘들어 매 단어의 시작마다
대문자를 써서 사람이 읽기 쉽게 하는것이 카멜케이스의 탄생 이유입니다

카멜케이스라고 지어진 이유는 낙타의 등이 중간에 튀어 나온것처럼
글자의 중간중간이 튀어나와 있기 때문입니다


5.

노래 한 곡을 나타내는 Song 클래스를 작성하라. Song은 다음 필드로 구성된다.



- 노래의 제목을 나타내는 title

- 가수를 나타내는 artist

- 노래가 발표된 연도를 나타내는 year

- 국적을 나타내는 country



또한 Song 클래스에 다음 생성자와 메소드를 작성하라.



- 생성자 2개 : 기본 생성자와 매개변수로 모든 필드를 초기화하는 생성자

- 노래 정보를 출력하는 show() 메소드

- main() 메소드에서는 1878년, 스웨덴 국적의 ABBA가 부른 "Dancing Queen"을 Song 객체로 생성하고 show()를 이용하여 노래의 정보를 다음과 같이 출력하라.

=================

출력 : 1978년 스웨덴국적의  ABBA가 부른 Dancing Queen

클래스파일

package song;

public class Song {
	String tittle;
	String artist;
	String country;
	int year;
	
	public Song() {
		
	}
	public Song(String tittle, String artist, String country, int year) {
		this.tittle = tittle;
		this.artist = artist;
		this.country = country;
		this.year = year;
	}
	void show() {
		System.out.println(year+"년 "+country+"국적의 "+artist+"가 부른 "+tittle);
	}
	
	
}

테스트파일

package song;

public class TestSong {

	public static void main(String[] args) {
		
		Song mySong = new Song("Dancing Queen", "ABBA", "스웨덴", 1978);
		mySong.show();

	}

}
























[ 6번 문제 ]



다음 멤버를 가지고 직사각형을 표현하는 Rectangle 클래스를 작성하라.



- int 타입의 x, y, width, height 필드 : 사각형을 구성하는 점과 크기 정보

- x, y, width, height 값을 매개변수로 받아 필드를 초기화하는 생성자

- int square() : 사각형 넓이 리턴

- void show() : 사각형의 좌표와 넓이를 화면에 출력

- 

- main() 메소드의 코드와 실행 결과는 다음과 같다.

=============================

출력:

(2,2)에서의 크기가 8*7인 사각형의 면적은 36 입니다. 


클래스파일

package rectangle2;

public class Rectangle {
	int x;
	int y;
	int width;
	int height;
	int a;
	
	Rectangle(int x, int y, int width, int height) {
		this.x=x;
		this.y=y;
		this.width=width;
		this.height=height;
		this.a=this.width*this.height;
	}
	
	    int square() {
		 return a;
	 }
	void show() {
		System.out.println(x+","+y+"에서의 크기가 "+width+"*"+height+"인 사각형의 면적은"+a+"입니다");
	}
	
}


테스트 파일

package rectangle2;

public class TestRectangle {

	public static void main(String[] args) {
		
		Rectangle area = new Rectangle(2,2,8,7); 
		area.show();
	}

}


2020-05-22

08-1 클래스 패스

AAA aaa = new AAA(); 
new란?
클래스 파일을 메모리에 업로드
객체 생성해야 하니까 클래스(설계도) 메모리에 올려봐 ㅇㅋ?

상대경로 
내폴더 기준으로 .은 이 다음
..은 내 폴더 기준 전으로

절대경로


08-02 패키지의 이해

패키지명이 물리적으로는 폴더명으로 들어간다
즉 다른 폴더에 같은 이름의 파일은 들어갈 수 있기 때문에 가능하다

매우중요함!
챕터 9 정보은닉 그리고 캡슐화

OOP Object Oriented Programming 객체지향언어프로그래밍

상속 Inheritance
정보은닉 information hiding
다형성 Polymorphism
캡슐화 Encapsulation

09-1 정보은닉

정보은닉을 해야하는 이유?
중요한 변수가 수정되지 못하도록 하는게 정보은닉! = private

09-2 접근수준 지시자

public > protected > default > private
ex)
private int 

int (디폴트는 아무것도 없는것)

protected int

public int

1.class일때
public은 어디서든 인스턴스 생성이 가능하다
디폴트는 동일 패키지로 묶인 클래스 내에서만 인스턴스 생성이 가능하다

2. 인스턴스일때 
4가지 지시자가 다 올 수 있다

private 
클래스내부 동일패키지

09-3 캡슐화

콘택 600을 떠올리면 이해하기 쉽다
잘짠 소스코드는?=캡슐화가 잘 되었다
모든 아날로그를 코드로 짜서 캡슐화 할순 없다
다만 좋은 예시와 가이드들은 존재한다

gof의 디자인패턴!
프로그램 잘짜는 고수들의 프로그램 짜는 방법

2020-05-22 면접족보

1. 절대 경로와 상대경로에 대하여 설명하시오.

2. set classpath=.;~~~~~~~~~~~  에서 classpath의 용도는?

3. 아래를 코딩 하시오.
GuguDan gu = new GuGuDan(7);
gu.show();  // 7단 출력
gu.setDan(8);
gu.show()  // 8단 출력.

4.패키지란 무엇이며, 용도는?

5.정보은닉이란?

6.아래의 프로그래밍을 하시오.
StarPrint sp = new StarPrint(5);
sp.floorShow(); //5층 피라밋
sp.setFloor(3); 
sp.floorShow(); //3층 피라밋
  *
 ***
*****

피라미드 찍는 소스
public class forClass {



	public static void main(String[] args) {

		// TODO Auto-generated method stub

		

		for(int i=0; i<10; i++)

		{

			for(int j=0; j<=10-i; j++)

			{

				System.out.print("   ");

			}

			for(int k=0; k<=2*i; k++)

			{

				System.out.print("☆");

			}

			System.out.println();

		}

	}

}


출처: https://jsieun73.tistory.com/13 [C/C++,C#,Java,Android]

7.객체지향 언어의 특징 4가지는(설명은 안해도 좋음)?

8. 아래의 접근 범위를 설명하시오.
-클래스 내에서의 public 과 default.
-멤버변수 와 함수의 private , default, protected(이거는 나중에)

9.캡슐화에 대하여 설명하시오.

10. 아래의 프로그램을 작성 하시오.

		Triangle t1 = new Triangle(10, 20);
		Triangle t2 = new Triangle(10, 20);
		Triangle t3 = new Triangle(10, 10);
		
		t1.equalTriangle(t2);
		t1.equalTriangle(t3);

===출력====
같은 삼각형 입니다.
다른 삼각형 입니다.
11.디자인패턴 책의 저자의 이름은 누구이며, 소개된 패턴의 이름만 한번씩 읽어 보세요.

------------------------------------------------------------------------------------------------------------------




2020-05-25

10-1 static 선언을 붙여서 선언하는 클래스 변수

static 함수에 인스턴스 라면이(변수, 함수) 올 수 없는 이유?
메모리 생성 시기가 다르기 때문에!(시간차가 있음)
static 에서 없는 변수(메모리에 업로드 되지 않았음)를 쓰려고 해서

인스턴스 함수? 앞에 static 없는 것
인스턴스 변수? 앞에 static 없는 것

static이 붙으면? 해당 변수를 접근을 하게 될때 클래스 이름으로 접근할 수 있다
쉽게 말해 공유할 수 있다
클래스 또는 인스턴스의 이름을 통해 접근할 수 있다
함수 내지는 변수

그럼 static은 언제 붙일까? 
인스턴스별로 가지고 있을 필요가 없는 변수
예를 들자면 PI = 3.14같은거
자주쓰는것들 맨날 new를 붙일 수 없으니까!
단순 기능 제공이 목적인 메소드들, 인스턴스 변수와 관련지을 필요 없는 것들

클래스 명 . 으로 접근할 수 있는것은
앞에 스태틱 붙은 변수
앞에 스태틱 분은 함수

10-2 static 선언을 붙여서 정의하는 클래스 메소드

1. 클래스변수
static이 붙으면? 해당 변수를 접근을 하게 될때 클래스 이름으로 접근할 수 있다

2. 스태틱변수


3. 공유함수

메모리 프로세싱
클래스파일을 실행하면 JVM이 메모리 메소드 영역에 객체 생성을 위해 업로드 시킨다 
메인함수부터 시작하게 될텐데 객체 생성에 필요한 각 인스턴스들 중 스테틱 부분을 찾아 메소드 영역에 방을 따로 만든다
그리고 클래스 안의 함수들을 메인부터 시작해서 주소를 생성하고 콜 스텍 영역에서 실행시킨다
힙 부분에서는 인스턴스가 실행되고 콜 스텍의 메인 함수가 인스턴스를 가리키게 됩니다, 메소드 영역에 스태틱 변수의 메모리방 주소도 참고하게 된다
두번째 작업부터는 새로운 영역을 다시 콜 스텍 영역에 생성하고 새로운 주소를 받고 힙 영역의 인스턴스를 가리키게 된다
단 스태틱으로 선언한 부분은 변하지 않기 때문에 전의 작업과 같은 메소드 영역 메모리방을 참고한다=주소가 같다

10-3 System.out.println 그리고 publics static void main()

컴파일러가 자동으로 해주는것 

1. default 생성자 만들어 주는것
2. java iang을 생략할 수 있다
많이 쓰는것들은 메소드 영역에 업로드 해놓고 공유하며 가져다 쓴다

메인 메소드 부분을 클래스 안에 넣어도 상관없음 하지만 인스턴스와 상관없는 부분이기 때문에 test클래스를 만들어 그안에 쓰는게 보통이다

10-4 또 다른 용도의 static 선언
-----------------------------------------------------------------------------------------------------------------------------------------------------------
2020-05-25 면접족보

1. static 함수에 인스턴스 라면(변수,함수)이 올수 없는 이유?

2. 클래스 변수, 공유변수, static 변수를 각각의 의미를 설명하시오.
3. 클래스 함수는 어떠한 경우에 만들어 주는 것이 좋은가?
4. 클래스 변수는 어떠한 경우에 만들어 주는 것이 좋은가?
5.금일 배운 CardTest 의 메모리 영역을 그리시오(외우세요).

6.다음을 프로그래밍 하시오.

Circle c1 = Circle c1(6);
Circle c2 = Circle c1(7);
Circle c3 = Circle c1(8);

Circle max = Circle.maxCircle(c1,c2,c3);

Sysout.out.println(max.radius)
--------------------------------------------------
package circle2;

public class Circle {
	int radius;
	
	Circle(int a){
		radius = a;
	}
	
	public int maxCircle(Circle c1,Circle c2,Circle c3) {
		if((c1.radius>c2.radius)&&(c1.radius>c3.radius)) {
		System.out.println("c1이 커요");
		}
		else if((c2.radius>c1.radius)&&(c2.radius>c3.radius)) {
			System.out.println("c2이 커요");
		}
		else if((c3.radius>c1.radius)&&(c3.radius>c2.radius)) {
			System.out.println("c3이 커요");
		}
		else {
			System.out.println("같아요");
		}
		return radius;
	}
	
}

package circle2;

public class TestCircle {

	public static void main(String[] args) {
		Circle c1 = new Circle(5);
		Circle c2 = new Circle(7);
		Circle c3 = new Circle(9);
	
		c1.maxCircle(c1, c2, c3);
		
		System.out.println(c1.radius);
	
		
	}

}
======================
출력 : 8

7. 컴파일러가 자동으로 하는거 2가지는?

8.다음을 프로그래밍 하시오


Sysout.out.println(MyCalculator.add(1, 2)); +	
Sysout.out.println(MyCalculator.min(1, 2)); -

출력: 
3
-1
 
package calculator;

public class Calculator {
	
	static int add(int a, int b) {
		int add = a + b;
		return add;
	}
	
	static int min(int a, int b) {
		int min = a - b;
		return min;
	}
}

package calculator;

public class TestCalculator {

	public static void main(String[] args) {
		System.out.println(Calculator.add(1,2));
		System.out.println(Calculator.min(1,2));

	}

}

----------------------------------------------------------------------------------------------------------------

2020-05-26 

11-1 메소드 오버로딩

함수가 같은데 컴파일링이 된다?
그럼 이걸 구분하려면 어떻게 해야 할까 내가 컴파일 개발자였다면?

타입정보와 갯수로 구번하게 된다!
1.메소드의 이름
2.메소드의 매개변수 정보

메소드 오버로딩
똑같은 함수 이름으로 타입과 파라미터 갯수를 다르게 해서 출력하는것
파라미터 부분을 달리해야 오버로딩이 된다
리턴 타입을 달리하는것은 오버로딩 해당사항이 아니다
(실제로 컴파일링 에러 뜸)
println은 가장 대표적인 메소드 오버로딩 예시

생성자의 오버로딩
ex) 여권이 있는사람과 여권이 없는 사람을 구분할때!

this의 용도
1. this 함수     this(.....);
또다른 생성자 함수 호출할때 쓰인다

2. this로 객체 자기자신이 가지고 있는 변수 내지 함수를 호출할때 쓰인다 

11-2 String 클래스

문자들의 연속된 집합의 공간을 잡아 놓고 
좀더 찾아보기

나는 안에 있는 문자열 자체를 비교하고 싶어!
문자열 비교는 equals로 비교해야한다 (주소 비교와는 다른 의미이다)

String 인스턴스는 Immutable(불변) 인스턴스이다
본래 원본(메모리 할당)의 값을 건드리지 못하고 다른 방을 파서 값을 수정한 다음 출력해준다

11-3 String 클래스의 메소드

문자열을 붙일때는 .concat String은 불변이기때문에 값을 붙여서 출력하는게 아닌 방을 새로 파서 붙인다음 출력해준다

append? 스트링 인스턴스를 최소한으로 써가면서 프로그래밍 할 수 있다

StringBuilder
문자열 데이터가 추가되고 수정될때 쓴다

StringBuilder와 StringBuffer는 기능적으로는 완전히 동일하다 다음의 세가지가 일치한다
생성자를 포함한 메소드의 수
메소드의 기능
메소드의 이름과 매개변수 선언

하지만! StringBuffer는 쓰레드 환경에서 안전하다
그래서 쓰레드 환경이 아닐때 StringBuffer를 사용하면 성능의 저하가 유발된다

12-1 콘솔출력

Printf C언어 문법이라고 함 자바 환경에서는 별로 쓰이지 않는다고 함

12-2 콘솔입력

Scanner 클래스
--------------------------------------------------------------------------------------------------
2020-05-26 면접족보

1.메써드 오버로딩 이란?
한 클래스 내에 이미 사용하려는 이름과 같은 이름을 가진 메소드가 있더라도! 
(1 매개변수의 개수) (2 매개변수의 타입)이 다르면 같은 이름을 사용해서 메소드를
정의할 수 있는데 이를 바로 메소드 오버로딩이라고 한다

메소드 오버로딩의 조건
1 메소드 이름이 같아야 한다
2 매개 변수의 개수 또는 타입이 달라야 한다
3 매개 변수는 같고 리턴 타입이 다른 경우는 오버로딩이 성립되지 않는다
4 오버로딩된 메소드들은 매개변수에 의해서만 구별될 수 있다


2.메써드 오버로딩의 대표적인 예와,메써드 오버로딩시 달리해야할 2가지는?
메소드 오버로딩의 대표적인 예는 println으로 들 수 있다
printStream 클래스에는 어떤 종류의 매개변수를 지정해도 출력할 수 있도록
10개의 오버로딩된 println 메소드를 정의해 놓았다
println();
println(boolean x);
println(char x);
println(char[] x);
println(double x);
println(float x);
println(int x);
println(long x);
println(Object x);
println(String x);


3.this는 무엇이며, This의 용도 2가지는?
자바에서 this는 객체, 자기자신을 나타냅니다

1 클래스 속성과 생성자/메소드의 매개변수의 이름이 같은 경우
-클래스 속성을 사용할때 this 키워드를 붙여줍니다
일반적으로 set/get 메소드의 매개변수 이름은 클래스의 속성 이름과 동일하게 정의되어 사용됩니다
생성자의 매개변수 또한 클래스 속성과 동일한 이름으로 정의되어 있을 시 안타깝게 자바는
객체의 속성을 가리키고 있다는 사실은 인지하지 못합니다
이럴때 바로 this 키워드가 사용되는데요
ex) 
class Fruit
this.name=name; 은
Fruit 객체의 name속성 = name 매개변수 형태가 되어 Fruit 객체의 속성에 값을 입력하게 됩니다 


2 클래스에 오버로딩된 다른 생성자 호출
-생성자의 최상단(가장 먼저)에 사용되어야 합니다
하나의 클래스에 여러개의 생성자가 오버로딩 되어 있을때
일부분을 제외하고는 서로 중복된 코드를 가지고 있는 경우가 많이 있습니다
이런 순간에 내부에 정의된 다른 생성자를 호출하여 코드의 중복을 피하고 깔끔한 소스를 작성할 수 있습니다

☆같은 클래스에 오버로딩된 다른 생성자를 호출할때에도 this 키워드가 사용됩니다

생성자를 호출할 때에는 원하는 생성자의 매개변수를 확인한 후
메소드를 호출하는 것 처럼 this(매개변수~)의 형대로 이용하면 됩니다

3 객체 자신의 참조값을 전달하고 싶을 때
어떤 메소드에서는 동작을 완료하고 리턴값으로 내부에서 호출하고자 하는 메소드의 매개변수로 
객체, 자기자신의 참조값을 전달하고 싶은 경우가 있습니다

이럴때에는 리던값에 this를 활용하므로써 구현이 가능합니다

3가지 상황 말고도 객체, 자기자신을 나타내야 할때에 this를 쓴다고 이해하면 도움이 될것입니다


4.문자열 생성의 두가지 방법은?
문자열이란 문자 상수의 집합이다
문자열은 실제로 char형 배열로 사용할 수 있지만 문자열의 이용은 매우 빈번한데 반해 코딩의 수가가 너무 크다
그래서 자바에서는 문자열을 String 클래스의 객체로 처리한다
String 클래스란 위에서 말한 것 처럼 문자열을 표현하기 위해 특화된 클래스이다 
내가 자바에서 큰따옴표("")를 활용해 문자열을 작성하면 자동으로 이를 String 클래스를 활용해 인스턴스화 한다
String 클래스의 코드를 보면 String 클래스에는 매개변수로 char형 배열 즉, 문자형 배열이 들어온다
이말은 즉 큰따옴표("")를 활용해 문자열을 작성하면 자동으로 컴파일러는 String 클래스를 활용하여 이를 char형 배열로 생성하는 것이다
화면에서 내가 보고있는 문자열은 사실 String 클래스에서 생성된 인스턴스의 참조변수이고 이것이 가르키는 주소값이
char형 배열의 주소값이라는 것이다 

String은 불변?
String 클래스를 활용하여 문자열 인스턴스가 생성이 되면 이를 변경할 수 없다 
그 이유는 문자열의 이용 빈도가 많아서 메모리를 효율적으로 쓰기위해 문자열은 같은 참조값을 가지게 된다
이는 동일한 문자열의 인스턴스를 하나만 생성해 공유한다
그리고 문자열은 덧셈(+)연산자를 통해 결합이 가능한데 이 경우는 결합으로 인해 인스턴스 내 문자열이 바뀌는게 아니다
이건 위에서 설명한 불변법칙과 연관되어 있는데 덧셈(+) 연산자를 활용하여 문자열을 결합하는 경우 새롭게 문자열이 담긴
인스턴스가 생성되는 것이다 덧셈(+) 연산자를 활용한 문자열의 결합은 메모리 공간을 많이 차지하게 되므로 되도록
결합 횟수를 줄이는게 좋다고 한다

문자열을 만드는 방법은 큰따옴표("")를 활용하는 방법과 String 클래스의 생성자를 활용해 만드는 방법이 있는데
문자열 자체를 이용하기에는 큰따옴표를 쓰는 방법이 더 편하다 그리고 결과또한 같다 
하지만 결과 내부를 살펴보면 이 둘의 문자열 생성에는 차이가 있다


5.아래의 차이는?
 String str1 = new String("Simple String");
 String str2 = "Simple String";

큰따옴표("")를 활용해 같은 내용의 문자열을 생성한 경우
ex) 
String str1 = "abc";
String str2 = "abc";
이 경우에는 "abc"는 하나만 생성되고 str1과 str2는 "abc"의 주소값이 저장된다

String 클래스의 생성자를 활용해 같은 내용의 문자열을 생성한 경우
ex)
String str3 = new String("abc");
String str4 = new String("abc");
각자 "abc"가 생성되고 str3, str4는 각자의 "abc"의 주소값이 저장된다


6. 아래가 false 를 리턴하는 이유와 true로 리턴하게 할려면?
if(str1 == str2) 

str1과 str2가 참조값이 다르기 때문이다 
쉽게 설명하자면 str1의 객체와 str2의 객체는 서로 주소도 다르고 업로드 되어있는 메모리 영역도 다르다
str1은 힙영역 str2는 메소드 에어리어
그리고 관계 연산자 ==는 해당 값이 같은지를 확인하는 것이 아니라 참조 값이 같은지를 확인한다



7.문제 11-1(263page) 프로그램을 작성하시오.

다음 주민등록 번호의 중간에 삽입된 - 를 지우고 공백으로 채워서 출력하는 프로그램을 작성해 보자
990925-1012999


8.String 과 StringBuffer 의 차이는?
자바에서 문자열을 다루는 대표적인 클래스는 String, StringBuffer, StringBuilder가 있습니다
연산이 많지 않을때에는 위에 나열된 어떤 클래스를 사용하더라도 이슈가 발생할 가능성은 거의 없습니다
하지만 연산횟수가 많아지거나 멀티쓰레드, Race condition 등의 상황이 자주 발생한다면 
각 클래스의 특징을 이해하고 상황에 맞는 적절한 클래스를 사용하는게 좋습니다

String 클래스와 Buffer,Builder의 가장 큰 차이점은 바로 속성입니다
String은 불변(immutable)의 속성을 가지고 있는데요

코딩으로 예를 들어보면
ex)
String str = "hello"; // String str = new String("hello");
str = str + "world"; // hello world

위의 예제에서 "hello" 값을 가지고 있던 String 클래스의 참조변수 str이 가리키는 곳에 저장되어있는
hello에 world 문자열을 더해 hello world로 변경한 것으로 보여 지는데요

하지만! 기존에 hello 값이 들어가있던 String 클래스의 참조변수 str이 
hello world라는 값을 가지고 있는 새로운 메모리영역을 가리키게 변경되고 처음 선언했던 "hello"로 값이 할당되어 있던
메모리 영역은 Garbage로 남아있다가 GC(garbage collection)에 의해 사라지게 되는 것 입니다
String 클래스는 불변하기 때문에 문자열을 수정하는 시점에 새로운 String 인스턴스가 생성되는 거죠

위와같이 String은 불변성을 가지기 때문에 변하지 않는 문자열을 자주 읽어 들이는 경우 String을 사용하면 좋은 성능을
기대할 수 있습니다 하지만 문자열 추가, 수정, 삭제, 등의 연산이 빈번하게 발생하는 알고리즘에 String 클래스를 사용하면
힙 메모리에 많은 임시 가비지데이터가 생성되어 힙 메모리 부족으로 어플리케이션 성능에 치명적인 영향을 끼치게 됩니다

String과는 반대로 StringBuffer, StringBuilder는 가변성(mutable)이기 때문에 .append() .delete 등의 API를 활용하여
동일 객체내에서 문자열을 변경하는것이 가능합니다 따라서 문자열의 추가, 수정, 삭제가 빈번하게 발생하는 경우라면
String 클래스가 아닌 StringBuffer, StringBuilder를 사용하셔야 합니다

☆StringBuffer, StringBuilder 이 둘의 차이 살펴보기

가장 큰 차이점은 동기화의 유무입니다 StringBuffer는 동기화 키워드를 지원하여 멀티쓰레드 환경에서 안전하다는 점
(thread-safe) 참고로 String도 불변성을 가지기 때문에 멀티쓰레드 환경에서의 안정성을 가지고 있습니다

반대로 StringBuilder는 동기화를 지원하지 않기 때문에 멀티쓰레드 환경에서 사용하는것은 적합하지 않습니다
그러나 동기화를 고려하지 않는 단일쓰레드 환경에서는 StringBuffer 보다 뛰어납니다

★정리

String : 문자열 연산이 적고 멀티쓰레드 환경일 경우
StringBuffer : 문자열 연산이 많고 멀티쓰레드 환경일 경우
StringBuilder : 문자열 연산이 많고 단일쓰레드 이거나 동기화를 고려하지 않아도 되는 경우


9.아래를 String 함수등을 사용하여 프로그래밍 하시오.
//1. 마지막 3글자 자르기
String str = "ABCDEFG"; 
String result = 소스코딩      
System.out.println(result)
 //결과값EFG

11.아래를 String 함수등을 사용하여 프로그래밍 하시오.
//2. 특정문자 이후의 문자열 제거
String str = "ABCD/DEFGH";
String result = 소스코딩
System.out.println(result); 
//결과값 DEFGH

12. 아래를 프로그래밍 하시오.
Rectangle r1 = new Rectangle(5,6);
Rectangle r2 = new Rectangle(7,9);

Rectangle r3 = Rectangle.compareRect(r1,r2);

System.out.println(r3.getHeight() + " : " + r3.getWidth()  + "입니다.");
=============================
출력 : 9 : 7 입니다.
 
2020-05-27 13챕터 배열

13-1 1차원 배열의 이해와 활용

배열이란?
연속된 공간에 데이터를 넣는것 배열에서 중요한것 연속적으로!

2020-05-27 면접족보

1. 아래의 Grade 클래스를 완성하시오.
   - 3과목은 스캐너 객체로 받음

Grade me = new Grade(math, science, english);
System.out.println("평균은 "+me.average()); // average()는 평균을 계산하여 리턴

2.아래와 같이 원의 넓이를 구하는 프로그램을 작성하시오.

원의 반지름을 입력하세요 : 10
원의 넓이는 314 입니다.
계속 하시겠습니까 yes면 y No이면 n: y
원의 반지름을 입력하세요 : 10
원의 넓이는 314 입니다.
계속 하시겠습니까 yes면 y No이면 n: n
프로그램을 종료 합니다.

3.아래와 같은 프로그램을 작성하시오.

아래중 고르세요(1.삼각형 2.사각형 3.원) >> 2
가로 입력하세요>>4
세로 입력하세요>>5
넓이는 20입니다.
계속 하시겠습니까 yes면 y No이면 n: y
아래중 고르세요(1.삼각형 2.사각형 3.원) >> 1
가로 입력하세요>>4
세로 입력하세요>>5
넓이는 10입니다.
계속 하시겠습니까 yes면 y No이면 n: n
프로그램을 종료 합니다.

4.6개의 정수를 담는 배열을 선언후, 로또 번호 6개 생성하여 출력하는
프로그램을 짜시오.
-번호생성은 Random 함수 또는 객체를 참고 할것.
-숫자가 중복되지 않을것.


 

5.아래의 메모리 그림을 그리시오.
int[] ref = new int[5];


   Box[] ar = new Box[3];

   // 배열에 인스턴스 저장
   ar[0] = new Box("First");
   ar[1] = new Box("Second");
   ar[2] = new Box("Third");

6.가위바위보 게임을 만드시오.(시간남을때 해주세요)

--------------------------------------------------------------------------------------------------------------

2020-05-28 

13-2 enhanced for문
코드의 양이 줄고 배열의 길이와 요소에 신경 쓸 필요가 없다
for-each라고 실무에서 표현한다고 함

13-3 다차원 배열의 이해와 활용
배열로 구구단 짜봤음

14챕터 클래스의 상속 1:상속의 기본

14-1 상속의 기본 문법 이해
코드의 재활용을 위한 문법입니다 X
연관된 일련의 클래스에 대해 공통적인 규약을 정의할 수 있다 O

쉽게 말해서 부모 클래스에 가지고 있는 함수를 다른 클래스에서 활용할 수 있다
부모의 함수를 불러오려면 일단 부모의 생성자를 호출하여야 한다(그래야 메모리에 올려서 불러올 수 있으니까)
(호출할 상위 클래스의 생성자 명시하지 않으면 defalut 생성자 호출함)

super 함수 사용하면 부모의 생성자를 호출할 수 있다

자바는 단일 상속만 가능하다 다중 상속을 지원하지 않는다 한 클래스에서 상속할 수 있는 최대 클래스의 수는 한개이다
즉 부모가 두개 이상인건 안된다는 말

14-2 클래스변수, 클래스 메소드와 상속
-----------------------------------------------------------------------------------------------------------------------------------
2020-05-28 면접족보

1. 아래의 2차원 배열의  메모리 그림을 그리시오.
int[][] arr = {
   {11, 22, 33},
   {44, 55, 66}, 
   {77, 88, 99}
};
손으로 정리!

2. 아래를 프로그래밍 하시오.
 - 10 개의 배열을 선언후 1부터 100까지의 수중에서
랜덤하게 생성하여 10개의 배열에 넣는다.
- 아래의 max 변수에 해당 배열의 값중에 최대값을 반환하는 함수를 만드시오. 

int[] arr = new int[10];

int max = getMaxValue(arr) 

3. 아래를 프로그래밍 하시오.
 - 10 개의 배열을 선언후 1부터 100까지의 수중에서
랜덤하게 생성하여 10개의 배열에 넣는다.
- sortArr 에 내림차순으로 sorting 된 배열을 리턴한다.

int[] arr = new int[10];
....
int[] sortArr = getSortDESC(arr) 
.....

6. 아래를 프로그래밍 하시오.
 - Rectangle 배열 4개를 만든후 스캐너 객체로 가로와 세로를 입력하여 4개의 객체를 배열에 할당한다 
- 해당 배열중 넓이가 최대값을 찾아서 리턴

Rectangle[] rec = new Rectangle[3];
........
Rectangle maxRec = getMaxRec(rec) 
s.o.p("최대사각형 넓이는" +maxRec.getArea())


7. 아래를 프로그래밍 하시오.
 - Rectangle 배열 4개를 만든후 스캐너 객체로 가로와 세로를 입력하여 4개의 객체를 배열에 할당한다 
-  getSortingRec 사각형 배열을 내림차순 정렬한다.
-정렬이 제대로 되었는지 배열에 저장된 객체의 getArea()함수를 순서대로 호출한다.

Rectangle[] rec = new Rectangle[3];
........
Rectangle[] recSorting = getSortingRec(rec) 
......

6. 상속이란 무엇인가?
상속이란
우리가 생각하는 상속이라는 단어가 맞다 부모님이 자식들에게 재산을 물려주는것과 비슷하다
차이라고 한다면 자식(클래스)이 상속받고 싶은 부모(클래스)를 선택해서 물려받는다
이때, 상속받는 클래스를 자식클래스, 하위클래스 또는 서브 클래스라고 부른다
상속을 해주는 클래스를 부모클래스, 상위클래스 또는 슈퍼클래스라고 한다

자식 클래스가 부모 클래스로부터 상속을 받게되면 *부모 클래스의 필드와 메서드*를 물려받게 된다
단, 접근제어자가 private를 갖는 필드나 메소드는 상속이 불가하고 패키지가 다를경우 접근 제어자가 default인 경우도 상속이 불가능하다

그렇다면 이런 상속을 선언하는 방법은 무엇일까?
방법은 간단하다 상속받을 자식 클래스 뒤에 *extends* 키워드를 사용하고 부모 클래스를 적어주면 된다
ex)
class (자식)클래스명 extends (부모)클래스명 {...}
class A extends B {...}

상속을 하는 이유는 결국 더 좋은(빠르고, 유지보수가 쉽고, 중복이 적고, 통일성 있는)프로그램을 만들기 위해서다

http://blog.naver.com/PostView.nhn?blogId=heartflow89&logNo=220960019390
자세한 내용 참조

7. 다중상속이란?
자바에서는 *자식 클래스가 여러 부모로부터 다중 상속을 받는 것은 불가능*하다
즉 *1개의 부모 클래스로부터 단일 상속만 허용*된다 하지만 부모 클래스는 여러개의 자식 클래스에게 상속이 가능하다
ex)
class 학교

class 학교 extends 선생님

class 선생님 extends 학생

학교 → 선생님 → 학생 순으로 상속을 받습니다 

클래스 영역의 차이를 보면

학생 > 선생님 > 학교 입니다 (반대로 생각하면 됨)

얼핏 생각하면 최상위에 존재하는 학교 클래스가 하위 클래스인 선생님과 학생을 포함하는 형태일 것이라 생각하지만
자바에서 상속이 중요한 이유가 자원의 재사용성을 높이고 자원을 변형하거나 추가하는 역할을 하기때문에 
최하위에 존재할 것같은 학생 클래스는 부모로부터 상속받은 자원도 가지고 있고 자기 자신만의 자원도 가지고 있어서
위의 부등식의 형태로 그려집니다

https://commin.tistory.com/101
자세한 내용 참조

8. 다음 TV 클래스가 있다.

class TV {
	private int size;
	public TV(int size) { this.size = size; }
	protected int getSize() { return size; }
}

다음 main() 메소드와 실행 결과를 참고하여 TV를 상속받은 ColorTV 클래스를 작성하라.

public static void main(String args[]) {
		colorTV myTV = new ColorTV(32, 1024);
		myTV.printProperty();
	}

=====
출력:32인치 1024컬러


9. 문제

다음 main() 메소드와 실행 결과를 참고하여 ColorTV를 상속받는 IPTV 클래스를 작성하라.
public static void main(String args[]) {
		IPTV iptv = new IPTV("192.1.1.2", 32, 2048); // "192.1.1.2" 주소에 32인치, 2048 컬러
		iptv.printProperty();
	}
===출력
나의 IPTV는 192.1.1.2 주소의 32 인치 2048컬러

10. 다음은 2차원 상의 한 점을 표현하는 Point 클래스이다.

class Point {
	private int x, y;
	public Point(int x, int y) { this.x = x; this.y = y; }
	public int getX() { return x; }
	public int getY() { return y; }
	protected void move(int x, int y) { this.x = x; this.y = y; }
}

Point를 상속받아 색을 가진 점을 나타내는 ColorPoint 클래스를 작성하라. 다음 main() 메소드를 포함하고 실행 결과와 같이 출력되게 하라.

public static void main(String[] args) {
   ColorPoint cp = new ColorPoint(5, 5, "YELLOW");
   cp.setXY(10, 20);
   cp.setColor("RED");
   String str = cp.toString();
   System.out.println(str+"입니다. ");
}
======출력======
RED 색의 (10,20)의 점 입니다.

11.super의 용도 2가지에 대하여 설명하시오.
super 키워드는 부모 클래스로부터 상속받은 필드나 메소드를 자식 클래스에서 참조하는데 사용하는 참조변수 입니다
인스턴스 변수의 이름과 지역변수의 이름이 같을경우 인스턴스 변수 앞에 this 키워드를 사용하여 구분할 수 있었는데요
이와 마찬가지로 부모 클래스의 멤버와 자식 클래스의 멤버 이름이 같을경우 super 키워드를 사용하여 구별할 수 있습니다
이렇게 자바에서는 super 참조변수를 활용하여 부모 클래스의 멤버에 접근할 수 있습니다
this와 마찬가지로 super 참조변수를 사용할 수 있는 대상도 인스턴스 메소드 뿐이며 클래스 메소드에서는 사용할 수 없습니다

this() 메소드가 같은 클래스의 다른 생성자를 호출할때 사용된다면 super() 메소드는 부모 클래스의 생성자를 호출할때 사용됩니다
자식 클래스의 인스턴스를 생성하면, 해당 인스턴스에는 자식 클래스 고유 멤버뿐만 아니라 부모 클래스의 모든 멤버 까지도 포함되어 있습니다
따라서 부모 클래스의 멤버를 초기화하기 위해서는 자식 클래스의 생성자에서 부모 클래스의 생성자까지 호출해야만 합니다
이러한 부모 클래스의 생성자 호출은 모든 클래스의 부모 클래스인 Object 클래스의 생성자까지 계속 거슬러 올라가며 수행됩니다

따라서 자바 컴파일러는 부모 클래스의 생성자를 명시적으로 호출하지 않는 모든 자식 클래스의 생성자 첫줄에 자동으로
다음과 같은 명령문을 추가하여, 부모 클래스의 멤버를 초기화할 수 있도록 해줍니다

http://tcpschool.com/java/java_inheritance_super 자세한 내용 참조

12.protected 에 대하여 설명하시오.
1. Java의 접근자(modifier)들

Java 의 필드와 메소드들에 대한 접근 권한 제어를 modifier라고 한다. 

private

default / no modifier

protected

public 

위와 같은 4개의 modifier가 존재하고, 이중에 default는 따로 명시를 하지 않는 경우를 뜻한다. 
private은 같은 클래스 내에서만 접근 가능하고, default는 같은 폴더(패키지)내에서만 가능하고, 
protected는 같은 폴더(패키지)및 그 클래스를 상속(extends)해서 구현하는 경우 접근이 가능하며, 
public은 모든 클래스에서 접근이 가능하다. 

2. protected은 public과 별로 다른것 같지가 않은데
private과 default, public의 경우는 그 용도가 명확한데, protected의 경우는 좀 애매하게 보일 수 있다. 
왜냐하면 사실상 그 기능은 public과 같은 역할을 하기 때문이다. 
원하는 클래스의 메소드를 직접 instance를 만들어 사용할 수는 없지만, 상속을 하는 클래스만 만들면 자유롭게 사용이 가능하기 때문이다. 
실제로 부모와 동일한 기능을 할수 있도록 만들어주는데, protected와 public다를 바가 없어 보인다. 
그러나 사실 protected는 많은 의미를 내포하는 메소드이다. 

3. OOP에서의 protected의 역할
protected 는 잠재적으로 자식 클래스가 Override해서 바꾸어야 할 경우를 고려한 modifier이다. 
즉 완성되지 못한, 혹은 완성될 수 없는 클래스 멤버를 의미한다. 여기서 "완성되지 못한/ 완성될 수 없는"의 의미가 중요하다. 
클래스를 디자인한 개발자가 이 메소드에 대해서 앞으로 더 구현할 것이 남았다거나, 혹은 디자인 컨셉트로서 일부러 완성시키지 않은 경우 둘 다를 의미할 수 있다. 
public으로 된 메소드는 그대로 그냥 써도 충분한 이미 완성된 메소드를 의미한다.

protected의 경우는 자식 클래스의 특성에 따라 적절히 변경해주어야 하는 상황을 고려한 메소드이다. 
이런 경우가 언제 발생할까? 새(Bird)와 타조(Ostrich)라는 클래스를 생각해보자.

새는 일반적으로 날아서 이동한다. 즉 moveFast()라는 함수에서는 fly()라는 함수를 이용할수 있을 것이다. 
이 객체를 사용해서 대부분의 새들을 정의할 수 있다. 

public class Bird{

   void fly() {

       System.out.println("I am flying")

   }

   protected void moveFast() {

      fly();

   }

}

타조 클래스를 만들때도, 타조는 새의 일종이기에 새를 상속해서 만들 수 있다. 

public class Ostrich extends Bird {
    public static void main(String[] args) {

      Ostrich  ostrich = new Ostrich();

       ostrich.moveFast();

   }

   void run() {

       System.out.println("I am running")

   }

   protected void moveFast() {

      run();

   }

}

그런데 위에서 보듯이, 타조는 빨리 움직일때에, 날아서 이동할 수가 없다. 달리는 방법을 사용해야 한다. 
Bird의 행동패턴과는 다른 상황이 생겨버린 것이다. 그래서 타조의 경우에는 moveFast() 함수 안에서 run()을 사용하는 방법으로 고쳐야 한다. 
숙련된 자바 프로그래머는 Bird클래스의 moveFast()메소드의 protected 키워드를 통해서, 이 함수가 바뀔 경우가 존재할수 있음을 짐작할 수 있다. 

비슷한 예로 Java Class의 가장 상위 클래스인 Object class의 clone()과 finalize() 메소드를 보면, 두 객체 모두 protected로 선언되어 있다. 
즉 모든 자바 클래스는 clone()과 finalize()를 사용할 수 있다는 이야기이다. 
또 한편으로 보면, 모든 자바클래스는 clone() 과 finalize()시에 override를 해야 할 경우가 있지 않은지 고민할 필요가 있다는 뜻이다. 
실제로 JVM의 자바 클래스들을 보면 무수히 많은 클래스들이 clone()과 finalize()를 자신의 용도에 맞게 override하고 있는 것을 볼 수 있다.

4. Abstract와 protected의 용도상 차이점
그렇다면 abstract 메소드와는 무엇이 다를까? 
abstract 메소드는 abstract 로 선언된 클래스의 구현부를 일부러 비어놓아서, 그것을 상속하는 클래스는 반드시 해당 메소드를 구현해주어야 하는 방식이다. 
부모클래스는 그자체로는 존재 할수 없고, 단지 추상적인 개념일 뿐이다. 
실제 세상에 태어나는(instance)것은  자식 클래스에 의해서 이루어 지기 때문에,  자식 클래스는 반드시 abstract를 구현해야만 한다.

이에 반해 protected로 구현된 메소드는 반드시 자식클래스가 Override를 해야 할 필요가 없다. 
대부분의 경우에는 상속하는 클래스가 직접 구현할 필요는 없지만, 
그래도 특수한 상황에서는 protected로 선언된 메소드는 override해서 처리해야 할 수도 있음을 유저에게 알려주는 것이다. 
즉 protected는 굉장히 문서적으로, 클래스 상속을 하는 개발자에게 주의를 주는 방식인 셈이다. (abtraction은 강제적으로 override를 강제하는 구조라고 볼 수 있다)

5. Break Through OOP via Reflection
일반적으로 protected api는 외부 패키지에서 상속을 하지 않는 이상 사용될 수 없다고 알려져 있지만, 실제로는 Reflection API를 통해 사용이 가능하다. 
그만큼 reflection API는 OOP를 깨버릴 만큼 강력한 API인 셈이다. 
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------

2020-05-29 

15챕터 클래스의 상속 2: 오버라이딩

15-1 상속을 위한 두 클래스의 관계

IS-A 관계

~은 ~이다 
ex) 노트북은 컴퓨터이다 전기자동차는 자동차이다
애매하면 has-a(데이터 멤버를 가지고 있는것)

15-2 메소드 오버라이딩

자식은 부모의 변수, 메소드를 사용할 수 있지만 부모는 자식의 데이터에 접근이 안된다
(자식의 인스턴스가 메모리에 올라가 있지만 부모에는 없으므로 접근이 제한된다)

부모는 자식 부모=자식 
이게바로 다형성 polymorphism

메소드 오버라이딩이란?
부모-자식 관계에서(상속) 함수 이름부터 함수 인자까지 다 같다
다른것은 함수 안에 내용이 다른것!

인스턴스 변수는 오버라이딩이 되지 않는다(함수만 신경쓰자)

15-3 instanceof 연산자

2020-05-29 면접 족보

1.다형성이란?
다형성(polymorphism)이란 하나의 객체가 여러가지 타입을 가질 수 있는 것을 의미합니다 자바에서는 이러한 다형성을
부모 클래스 타입의 참조 변수로 자식 클래스 타입의 인스턴스를 참조할 수 있도록 하여 구현하고 있습니다
*다형성은 상속, 추상화와 더불어 객체 지향 프로그래밍을 구성하는 중요한 특징 중 하나입니다

2. 아래의 메모리를 그리시오.
class MobilePhone {
    protected String number;
    
    public MobilePhone(String num) {
        number = num;
    }    
    public void answer() {
        System.out.println("Hi~ from " + number);
    }
}

class SmartPhone extends MobilePhone { 
    private String androidVer;
    
    public SmartPhone(String num, String ver) {
        super(num);
        androidVer = ver;
    }    
    public void playApp() {
        System.out.println("App is running in " + androidVer);
    }
}
=======================================
	MobilePhone phone = new SmartPhone("010-555-777", "Nougat");
    	phone.answer();    	
    	SmartPhone s = (SmartPhone)phone;    	
    	s.playApp();

2.is-a 관계와 has-a 관계에 대하여 설명하시오.
https://eskeptor.tistory.com/57?category=928923 참조해야함(강의가 많음)
https://gbs1995.tistory.com/41 도식화가 잘되있음 손으로 정리할때 필요함

1. 클래스간의 관계 - 상속관계(inheritance) is-a
~은(는) ~다.
ex) 학생은 사람이다 (O) 사람은 학생이다 (X)

코드를 공통적으로 관리하기 때문에 코드의 추가 및 변경이 매우 용이하다
조상클래스의 변경이 있으면 자손클래스는 영향을 주지만, 자손 클래스가 변경되는 것은 조상 클래스에 아무런 영향이 없다
자손클래스의 인스턴스를 생성하면 조상클래스의 멤버와 자손 클래스의 멤버가 합쳐진 하나의 인스턴스로 생성된다

2. 클래스간의 관계 - 포함관계(composite) has-a
~은(는) ~을(를) 가지고 있다.
ex) 학생은 책을 가지고 있다 (O) 책은 학생을 가지고 있다 (X)

한 클래스의 멤버변수로 다른 클래스를 선언하는 것
작은 단위의 클래스를 먼저 만들고 이 들을 조합해서 하나의 커다란 클래스를 만든다


3.메소드 오버로딩과 오버라이딩의 차이점은?
메소드 오버로딩?
같은 클래스 내에서 같은 함수 이름으로 여러번 출력을 하는것을 오버로딩이라고 한다
대신 매개변수를 다르게 해서 실행하여야 한다 
메소드 오버로딩의 대표적인 예는 println

메소드 오버라이딩?
부모 클래스를 상속받은 자식 클래스에서 활용할 수 있으며 부모 클래스에서 가지고 있던 함수를 활용하여
새롭게 메소드를 만드는것을 메소드 오버라이딩이라 한다


4 책 323 page 14-1번



5.instanceof 연산자에 대하여 설명하시오.



6.남는 시간은 어제 프로그래밍 모두 중요합니다.(시간내에 풀수 있도록 계속 연습 부탁드리겠습니다.)


2020-06-01 

1. 다형성의 활용
원의넓이
사각형 넓이
삼각형 넓이
==========
각 넓이 객체 3개가 있다
3개 넓이의 총 합을 구하는 프로그램을 만드세요

각 넓이 구하는 클래스 만든 후 중복되는 getArea 함수를 클래스 하나 새로 파서 나머지 3개에 상속시킨다
출력 페이지에서는 배열을 활용해 for문으로 합을 구한다
Shape[] shapes = new Shape[3];

Shape[0] = new Circle(10);
shape[1] = new Rectangle(20,10);
shape[2] = new Triangle(20,10);

int totalArea=0;
for(Shape shape :shapes) {
totalArea = totalArea + shape.getArea();
}
System.out.println(totalArea);

16-1 상속이 도움이 되는 상황의 소개

이렇게 안하면 안된다 실무에서는 다형성을 적용해야 한다고 함
1. 표준(강제)를 정할 수 있다
(캡슐화의 기본) 사용자가 조금 더 편하게 사용할 수 있도록!

2. 유지보수가 용이하다(확장성)
고객은 프로그래밍을 모른다 고객의 요구사항에 맞춰 바꾸기가 수월하다
클래스안의 내용을 직접 수정하게 되면 이건 안좋은거다
이걸 활용하는 모든 데이터에 간섭이 생길 수 있음!
그래서 요구사항에 따른 새로운 클래스를 만들어서 다형성을 적용시키는게 좋다
(기존 클래스는 안 건드리는게 좋다)

16-2 Object 클래스와 final선언 그리고 @override
모든 클래스는 Object 클래스를 상속하게 되어있다
해쉬코드
클론
이퀄
이건 꼭 외워야 한다
그러므로 모든 클래스는 Object부모의 함수를 쓸 수 있다(상속되어 있으므로)
Object = 오버라이딩의 대표적인 예
@override
상위 클래스의 메소드를 오버라이딩 하는것이 목적이라는 선언(웬만해서는 붙이는것이 좋다)

17챕터 인터페이스와 추상클래스

17-1 인터페이스의 기본과 그 의미

추상메소드
구현 부분이 없는(몸통) 함수!
따라서 인스턴스 생성 불가 참조변수 선언 가능

*자식이 구현함*
interface Printable {
	public abstract void print(String str);
} 

class Printer implements Printable {
	public void print(String doc) {
		System.out.println(doc);
	}
}
추상 메소드 예시

상속과 구현 동시에 가능!
class Robot extends Machine implements motable, runnable

인터페이스의 본질적 의미
1. 표준 강제(캡슐화)
2. 빠른 개발속도

2020-06-01 면접족보

1.아래를 다형성의 활용하여 프로그래밍 하시오.

-원의 넓이
-사각형 넓이
-삼각형 넓이
==========
3개 넓이의 총합을 구하는 프로그램을 짜시오
3시간짜리

2. 아래의 출력 결과가 아래와 같이 나오도록 프로그래밍 하시오.
Circle circle = new Circle(10);
Object obj = new Circle(10);
System.out.println(obj);
=================
출력: 넓이는 314.13578561 입니다.
5글자를 해야지만 나온다 

3.Object 클래스에 대하여 설명하시오.
Object 클래스를 설명하기에 앞서 먼저 Java.lang 패키지를 알아둘 필요가 있다 
Java.lang은 자바 프로그램에서 가장 많이 사용되는 패키지이다 
import 문을 사용하지 않아도 자동으로 포함된다 그만큼 자바 프로그램의 기본이 되는 클래스들과 인터페이스들이 포함되어 있다

*Java.lang 패키지의 클래스 구조도
Object	String
	StringBuffer
	Boolean
	character
	number	Byte
		Short
		Integer
		Long
		Float
		Double

Object 클래스는 Java.lang 패키지 내의 최상위 클래스이며 
String 클래스는 변하지 않는 문자열을 다룰때 StringBuffer 클래스는 내용이 계속 변하는 문자열을 다룰 때 사용될 수 있다

Java.lang.Object 클래스는 자바 API의 모든 클래스와 사용자가 정의한 모든 클래스의 최상위 클래스이다
즉 모든 자바 클래스들은 Object 클래스로부터 상속받는다
또한 클래스를 정의할 때 클래스 선언부에 명시적으로 extends java.lang.Object를 지정하지 않아도 자동으로 상속받게 된다
즉 Object 클래스의 모든 메소드와 변수는 다른 모든 클래스에서도 사용 가능할 수 있다는 말이다

boolean equals(Object obj) 두 개의 객체가 같은지 비교하여 같으면 true를, 같지 않으면 false를 반환한다.

String toString() 현재 객체의 문자열을 반환한다. 

protected Object clone() 객체를 복사한다. 

protected void finalize() 가비지 컬렉션 직전에 객체의 리소스를 정리할 때 호출한다. 

Class getClass() 객체의 클래스형을 반환한다. 

int hashCode() 객체의 코드값을 반환한다. 

void notify() wait된 스레드 실행을 재개할 때 호출한다. 

void notifyAll() wait된 모든 스레드 실행을 재개할 때 호출한다. 

void wait() 스레드를 일시적으로 중지할 때 호출한다. 

void wait(long timeout) 주어진 시간만큼 스레드를 일시적으로 중지할 때 호출한다. 

void wait(long timeout, int nanos) 주어진 시간만큼 스레드를 일시적으로 중지할 때 호출한다.


4.아래와 같이 출력을 하는 이유에 대하여 설명하시오.
Circle circle = new Circle(10);
System.out.println(circle);
===============
Circle@15db9742

Circle 이라는 클래스로 객체 생성을 위한 인스턴스 실행 과정이다
메모리 메소드 에어리어에 클래스 파일이 업로드 되고 그에따른 인스턴스가 힙 영역에 업로드 되어 실행된다
그 후 메소드 에어리어에 업로드 된 클래스 파일이 힙 영역의 인스턴스 주소를 참조하는데 
인스턴스 내에 변수나 함수를 사용하지 않고 바로 인스턴스 출력만을 실행하였기 때문에 참조하는 주소값만 나오게 된다  

6.@Override 에 대하여 설명하시오.
부모 클래스에 있는 메소드를 자식 클래스에서 재정의 하는 것입니다 자식 클래스가 부모 클래스를 상속하여 자식에게 없는
메소드를 호출하면 부모클래스에 가서 해당 메소드를 찾게 됩니다 만약 부모 클래스의 메소드를 자식 클래스에서 동일한
이름으로 다시 재정의 하면 부모클래스의 메소드를 찾지 않고 자식 클래스의 메소드를 호출하개 됩니다
이것을 오버라이드(재정의)라고 합니다
(예시)

package com.java.ex;

-부모클래스-
public class ParentClass {

	public ParentClass() {

		// TODO Auto-generated constructor stub

	}	

	public void method1() {

		System.out.println("ParentClass method1()");

	}

	public void method2() {

		System.out.println("ParentClass method2()");

	}

} 

-자식클래스-
package com.java.ex;

public class ChildClass extends ParentClass {

	public ChildClass() {

		// TODO Auto-generated constructor stub

	}

	@Override

	public void method1() {

		// TODO Auto-generated method stub

		System.out.println("ChildClass method1()");

	}

	

	public void method3(){

		System.out.println("ChildClass method3()");

	}

}

-출력 클래스-
package com.java.ex;

public class MainClass {

	public static void main(String[] args) {

		ChildClass child = new ChildClass();

		child.method1();

		child.method2();

		child.method3();

	}

}
=========출력=============
ChildClass method1()
ParentClass method2()
ChildClass metthod3()

부모에게는 1번 2번 메소드가 있고 자식에게는 1번 3번 메소드가 있습니다
메소드 1번은 재정의가 되었고 메소드 2번은 재정의가 되지 않았고 메소드 3번은 자식 클래스에서 생성한 것입니다
따라서 결과는 자식클래스의 메소드1번이 출력되고 부모클래스의 메소드2번이 출력되고
마지막으로 자식클래스의 메소드 3번이 출력됩니다

super키워드란?
재정의(override)는 잘 만들어진 클래스를 상속받아서 일부 메소드를 수정 할 수 있다는 것입니다 
하지만 자식 클래스에서 부모 클래스를 재정의(override)를 하면 부모 클래스의 메소드는 사용할 수 없습니다
*이것이 재정의(override)의 단점입니다 그래서 나온 키워드가 super입니다 
super키워드는 자식 클래스에서 부모 클래스의 메소드를 사용하고자 할때 super 키워드를 사용하게 됩니다
(예시)

-부모클래스-
package com.java.ex;

public class ParentClass {

	public ParentClass() {

		System.out.println("부모 클래스 입니다.");		

	}

	public void method1() {

		System.out.println("부모 클래스 method1() 입니다.");

	}

}

-자식클래스-
package com.java.ex;

public class ChildClass extends ParentClass {

	public ChildClass() {

		System.out.println("자식 클래스 입니다.");

	}

	@Override

	public void method1() {

		super.method1();

		System.out.println("자식 클래스 method1() 입니다.");

	}

}

-메인클래스-
package com.java.ex;

public class MainClass {
	public static void main(String[] args) {
		ChildClass child = new ChildClass();
		child.method1():
==========출력=============
부모 클래스 입니다.
자식 클래스 입니다.
부모 클래스 method1() 입니다
자식 클래스 method1() 입니다

-클래스가 호출되는 순서-
상속받은 자식 클래스가 존재 한다면 부모 클래스가 먼저 호출되고 다음으로 자식 클래스가 호출됩니다
-부모 클래스가 제일 먼저 실행됩니다
-다음으로 자식 클래스가 실행됩니다
-자식 클래스의 메소드1()이 실행 되어야 하지만 super 키워드로 인해 부모 클래스의 메소드1()이 실행됩니다
-마지막으로 자식 클래스의 오버라이드된 메소드1()이 실행됩니다

https://securityspecialist.tistory.com/41 참조

7.interface 에 대하여 설명하시오.
-interface에 올수 있는 두가지는?

8.abstract 키워드에 대하여 설명하시오.


2020-06-02 

17-1 인터페이스의 기본과 그 의미
인터페이스?
표준=강제=약속 USB와 비슷하게 생각하면 편하다
요즘은 OS에서 인터페이스를 제공한다고 한다
책 366페이지 예제로 연습해봄

인터페이스에서 선언되는 메소드와 변수?
1. 추상메소드
2. 상수

인터페이스 기능 확장
기능이 추가되면 인터페이스 메소드도 당연히 추가가 되어야함(제조사가 업데이트)
그렇다면 느리고 오류가 많이 발생 그러면 더 좋은 방법이 있을까?

인터페이스도 서로 상속이 가능하다 그래서 상속으로 진행하면 편하다!

참조변수 instanceof 클래스명
참조변수가 참조하고 있는 인스턴스의 실제 타입을 알아보기 위해 instanceof 연산자를 사용합니다. 
주로 조건문에 사용되며, instanceof의 왼쪽에는 참조변수를 오른쪽에는 타입(클래스명)이 피연산자로 위치합니다. 
그리고 연산의 결과로 boolean값인 true, false 중의 하나를 반환 합니다.
instanceof를 이용한 연산결과로 true를 얻었다는 것은 참조변수가 검사한 타입으로 형변환이 가능하다는 것을 뜻합니다.

abstract 추상클래스=미완성클래스 
구현하려면 상속을 시켜서 자식이 구현하게 해야한다
추상클래스가 있는 클래스 자체에도 abstract가 붙는다

2020-06-02 면접족보

1. 다음을 프로그램 하시오.
interface Printable { // MS가 정의하고 제공한 인터페이스
   public void print(String doc);
}
 SPrinterDriver 와 LPrinterDriver를 만드시오
======================

public static void main(String[] args) {
   String myDoc = "This is a report about...";
   
   // 삼성 프린터로 출력
   Printable prn = new SPrinterDriver();
   prn.print(myDoc);
   System.out.println();

   // LG 프린터로 출력
   prn = new LPrinterDriver();
   prn.print(myDoc);
}

2. interface 문법중 default 에 대하여 설명하시오.
인터페이스란?
구현할것으로 기대 되는것을 껍데기만 정의해 놓은것
-어떤 객체가 있고 그 객체가 특정한 인터페이스를 사용한다면 그 객체는 반드시 인터페이스의 메소드들을 구현해야 함
-인터페이스의 멤버의 접근제어자는 반드시 public으로 명시해야함(안하면 컴파일에러)

기존의 인터페이스는 껍데기만 만들어놓을 수 있었지 미리 기능을 구현해 놓을 수는 없었다
그래서 인터페이스를 구현하는 클래스는 같은 기능이여도 중복으로 기능을 구현해야하는 경우가 생겼다
Java8 버전에서는 default 인터페이스 메소드가 추가되어 인터페이스에 기본 기능을 구현할 수 있게 되었다
-인터페이스가 default 키워드로 선언되면 메소드가 구현될 수 있다 또한 이를 구현하는 클래스는 default 메소드를 오버라이딩 할 수 있다
-인터페이스가 변겨잉 되면 인터페이스를 구현하는 모든 클래스들이 해당 메소드를 구현해야 하는 문제가 있다
이런 문제를 해결하기 위하여 인터페이스에 메소드를 구현해 놓을 수 있도록 하였다

http://hong.adfeel.info/backend/java5/ 참조

3.abstract 클래스에 대하여 설명하시오.
https://limkydev.tistory.com/188 자세한 내용 참조

실체클래스는 실체가 드러나는 클래스
추상클래스는 실체 클래스의 공통적인 부분을 추출해 어느정도 규격을 잡아놓은 추상적인 클래스이다
그래서 실체클래스 실제 객체를 생성할 정도의 구체성을 가지는 반면 추상클래스는 아직 메서드와 내용이 추상적이기 때문에
객체를 생성할 수 없게 만들었다

객체를 직접 생성할 수 있는 클래스=실체클래스
실체클래스들의 공통적인 특성을 추출해서 선언한 클래스=추상클래스
포인트 3개
1. 추상클래스는 뭐? 실체클래스의 공통적인 부분(변수, 메서드)를 추출해서 선언한 클래스
2. 추상클래스는 객체를 생성할 수 없다 아직은 실체성이 없고 구체적이지 않기 때문에
3. 추상클래스와 실체클래스는 어떤관계? 상속관계

그렇다면 추상클래스는 왜 사용할까?(제일중요)
1. 공통된 필드와 메서드를 통일할 목적
추상클래스에서 미리 정의한 필드와 메서드가 있다면 실체클래스는 추상클래스의 필드와 메서드명을 변경할 수 없고
무조건 해당 명령으로 구현해야 한다 따라서 필드와 메서드 이름을 통일하여 유지보수성을 높이고 통일성을 유지할 수 있다

2. 실체클래스 구현 시 시간절약
예를들어 내가 자동차를 구현해야 하는데 자동차 추상클래스를 상속받으면 자동차에 공통적으로 들어가야 하는 필드와 메서드가
자연스럽게 오버라이딩된다 즉 강제로 주어지는 필드와 메서드를 가지고 나만의 스타일대로 구현만 하면 된다
이로써 설계시간이 절약된다 구현하는데만 집중할 수 있다

3. 규격에 맞는 실체클래스 구현
아무리 자기 스타일대로 클래스를 구현한다고 해도 그것도 결국엔 규격안에서 구현하는 것을 허락한다는 것
규격도 없이 아무렇게나 구현을 해서는 안된다 개발은 혼자하는 것이 아니기 때문!
그래서 모두가 약속한 필드와 메서드 그리고 설계 규칙에 녹아져있는 규격에 맞는 클래스를 구현해야 한다
그래야 코드 수정 시 영향도를 적게 가져가면서 유지보수성을 높일 수 있다

추상클래스를 상속받은 실체클래스들은 반드시! 추상메서드를 재정의(오버라이딩) 해서 실행 내용을 작성해야 한다
만약 그렇지 않으면 컴파일 에러를 발생시켜 실행조차 불가능하게 된다


4.추상클래스와 interface의 차이는 무엇인가요?
추상클래스와 인터페이스는 얼핏보면 상당히 비슷해 보이는데요 차이점을 알아보기 전에 공통점을 알아보도록 해요
※공통점
추상클래스와 인터페이스는 선언만 있고 구현 내용이 없는 클래스이다
(자바 8부터 인터페이스에 default 메소드 구현이 가능해 졌지만 일반적으로 인터페이스는 구현이 없다)
따라서 인터페이스와 추상클래스를 가지고 새로운 인스턴스(객체)를 생성할 수 없다
추상클래스를 extends로 상속받아 구현한 자식클래스나 인터페이스를 implements하고 구현한 자식클래스만이 객체를 생성
결국 자식클래스가 무언가 반드시 구현하도록 위임해야할 때 사용해야 한다

그렇다면 이 둘의 차이는 무엇일까?
이 둘의 차이점 키워드는 목적이다!
추상클래스의 목적은 공통적인 기능을 하는 객체들의 추상화다
사자, 호랑이, 원숭이, 고래 = 포유류 그렇다면 추상클래스는 포유류가 적합 왜냐 포유류는 젖먹이 동물이라는 공통점
그렇다면 여기서 추상클래스 사용의 포인트는?
책에서 보던 is-a 관계를 떠올려보자
만들어야할 여러 클래스들의 공통점을 찾아 추상화시켜서 사용하는것이 개발에서 이득일때 사용한다 
냉장고, TV, 세탁기, 에어컨 등을 가전제품이라는 추상클래스로 만드는것이 현명한 방법

반면 인터페이스는 구현하는 모든 클래스에 대해 특정한 메서드가 반드시 존재하도록 강제하는 역할이다
즉 구현 객체가 같은 동작을 한다는 것을 보장하기 위한 목적이다
위의 추상클래스 예제처럼 포유류는 젖을 먹인다라는 목적으로 인터페이스를 적용할 수도 있을것이다
그리고 인터페이스는 다중 상속도 가능하다
그래서 판단을 잘 해서 써야한다

결론 차이점을 말할 때 다중 상속이 되냐 안되냐가 포인트가 아니라 목적이 다르다라는게 포인트다!

https://jeong-pro.tistory.com/82 참조


2020-06-03 18 예외처리

18-1 자바 예외처리의 기본
자바에서 말하는 예외?
예외적인 상황을 줄여서 예외라고 한다
단순한 문법 오류가 아닌 실행 중간에 발생하는 '정상적이지 않은 상황'을 뜻한다
'죽어도 객체'

18-2 예외처리에 대한 나머지 설명들
try
catch
finally
이 문법이 정석

1.아래의 메모리를 정확히 그리시오.
		Rectangle[] recArr = new Rectangle[3];
		Scanner scanner= null;
		
		for(int i=0;i<3;i++) {
			scanner = new Scanner(System.in);
			int width = scanner.nextInt();
			int height = scanner.nextInt();
			recArr[i] = new Rectangle(width, height);
		}
		
		
		Rectangle maxRec = Rectangle.getMaxRec(recArr);

=======================
public static Rectangle getMaxRec(Rectangle[] recArr) {
		Rectangle maxRec = recArr[0];
		
		for(Rectangle rec: recArr) {			
			if(maxRec.getArea() < rec.getArea()) {
				maxRec = rec;
			}		
		}
		
		for(int i=0 ; i <recArr.length; i++) {			
			if(maxRec.getArea() < recArr[i].getArea()) {
				maxRec = recArr[i];
			}		
		}		
		return maxRec;		
	}
 
2. 예외와 에러의 다른점은?

3. 예외에 대한 클래스 상속도를 간단하게 그리시오.

4.예전의 계산기 프로그램이 아래와 같이 에러가 난다. 예외처리를 구문을 적용하여, 죽지 않게 만드시오.

첫번째 숫자를 넣으세요:1
연산기호를 넣으세요:/
두번째 숫자를 넣으세요:3
1 / 3 = 0
continue? Y or N:y
첫번째 숫자를 넣으세요:1
연산기호를 넣으세요:/
두번째 숫자를 넣으세요:0
Exception in thread "main" java.lang.ArithmeticException: / by zero
	at Calculator.execute(Calculator.java:34)
	at CalculatorTest.main(CalculatorTest.java:69)

5.예외처리 에서, 아래의 용어를 설명하시오.
-checked Excetpion이란 unchecked Exception이란?
-finally
-throws

2020-06-04 19 자바의 메모리 모델과 Object 클래스

19-1 자바 가상머신의 메모리 모델
운영체제 관점에서는 가상머신도 그냥 프로그램의 하나

19-2 Object 클래스
String 클래스는 내용 비교를 하는 형대로 equals 메소드를 오버라이딩 하고 있다

2020-06-04 면접족보

1.OS의 역할은?

2.자바 메모리 영역에 대하여 설명하시오.

-MA

-Call stack

-heap

3.Object 클래스가 가지는 각각의 함수는?

4. 아래와 같이 나오도록 프로그래밍 하시오

==============================



Person person1 = new Person("jeong-pro", 27);

Person person2 = new Person("jeong-pro", 27);



System.out.println(person1.equals(person2));//true 로 반환

person 클래스

package person;

public class Person {
	String name;
	int age;

	Person(String name, int age) {
		this.name = name;
		this.age = age;
	}

	@Override
	public boolean equals(Object obj) {
		if ((this.age == ((Person) obj).age) && (this.name == ((Person) obj).name))
			return true;
		else
			return false;
	}

}

Test 클래스
package person;

public class Test {

	public static void main(String[] args) {

		Person person1 = new Person("jeong-pro", 27);

		Person person2 = new Person("jeong-pro", 27);

		// person1 = person2;

		System.out.println(person1.equals(person2));

	}

}


5.shallow copy 와 deep copy 차이는 무엇인가?

shallow copy는 복제의 대상을 참조하는 또다른 인스턴스를 만드는 행위라 할 수 있고
deep copy는 한 인스턴스의 내용을 복제하여 새로운 메모리 공간에다가 생성한다는 의미라고 보면 됌
https://marshallslee.tistory.com/entry/%EC%9E%90%EB%B0%94-Cloneable-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4-%EA%B7%B8%EB%A6%AC%EA%B3%A0-deep-copy-vs-shallow-copy
https://yyman.tistory.com/529 그림이 잘 되어 있음



6.439 19-2 번의 문제를 푸시오.
코딩


7.431page 와 깊은복사의 메모리를 그리시오.

 
2020-06-05 자바의 기본 클래스
20-1 래퍼클래스
기본 자료형의 값을 인스턴스로 감싸는 목적의 클래스

20-2 BigInteger 클래스와 BigDecimal 클래스

20-3 Math 클래스와 난수의 생성, 그리고 문자열 토큰의 구분
2의 16제곱? Math.pow(2, 16);
pow 제곱함수

currentTimeMillis 1970년 1월 1일부터 지금의 시각까지 체크함

토큰? 
PM : 08 : 45
이 문자열의 구분자가 :일때 토근은 다음 세가지
PM 08 45

20-4 Arrays 클래스 
실무에서는 잘 안쓴다
이것보다 훨씬 더 좋은게 있기 때문에 안쓴다

21장 제네릭1
21-1 제네릭의 이해
set 담는다 get 꺼낸다

제네릭 이전의 코드가 갖는 문제점
1. 프로그래머의 실수가 컴파일 과정에서 발견되지 않는다
2. 프로그래머의 실수 자체가 실행과정에서 조차 발생하지 않을 수 있다 정말 큰문제!
<T>

2020-06-08 

회의 하는법
객체지향적으로 설계한다
가위바위보 게임을 만들어 보자!
사람vs컴퓨터 = 가위바위보게임

사람은 입력=키보드
컴퓨터는 랜덤함수

그렇다면 유저 클래스 판다
그리고 달라지는 값은?
한놈은 키보드 한놈은 랜덤
달라지는 부분은 인터페이스로 구현
그래서 바뀌는 부분을 오버라이딩 해보자!

클래스는 사람 컴퓨터 가위바위보 게임으로 나눈다
그리고 테스트 페이지 만든다
*전략이 중요함 애플리케이션에서 달라지는 부분을 찾아내고 달라지지 않는 부분으로부터 분리시킨다*
전략 패턴의 핵심! 상속이 아닌 구성을 활용

21-2 제네릭의 기본 문법
제네릭을 쓰는 이유는?
런타임 오류를 최대한 막기 위해서
차라리 컴파일 오류가 나는게 낫다 런타임오류는 더 안좋은거다

일반적인 관례 
한 문자로 이름을 짓는다 
대문자로 짓는다

제네릭은 함수 앞에도 붙을 수 있다
제네릭 메소드

클래스 옆에 제네릭을 선언하면 클래스 전체가 제네릭으로 선언이 되는데
제네릭 선언을 하고 싶지 않은 부분도 있을 수 있기 때문에 부분적으로 제네릭을 선언할 수 있다
그게 제네릭 메소드

1강 web과 html
프로토콜 : 통신 = 커뮤니케이션
프로토콜은 약속(통신규약)

포트번호는 프로그램번호(서비스번호)
해당컴퓨터의 구동되고 있는 프로그램을 구분할 수 있는 번호


2020-06-08 면접족보

1.제네릭을 쓰는 이유는?

2.496page 문제 21-1 번을 푸시오.

3.제네릭 메소드란?

4.아래가 호출되도록 BoxFactory 클래스를 만드시오.
Box<String> sBox = BoxFactory.<String>makeBox("Sweet");
Box<Double> dBox = BoxFactory.<Double>makeBox(7.59);

5.다음용어를 정리하시오.
-http
-도메인네임
-포트번호


2020-06-09 챕터 22 제네릭2

22-1 제네릭의 심화 문법

와일드카드 = 폴리모티즘 다형성을 적용하고 싶을때 사용한다!
문법 <?> 제네릭계의 최대의 부모 모든 인자를 다 부여받을 수 있다
와일드카드 문법에서 super 앞에는 T가 못온다
와일드카드 super 앞에는 Integer Number Object만 올 수 있다

즉 상한제한을 해버리면 꺼내는 것은 가능하지만 넣는것은 불가능하다
왜 셋은 안되는가
토이이거나 토이를 상속하는 애들만 올수있음
근데 컴파일러는 왜 못넣는걸까

Toy
Car
Robot

Box<Car>
Box<Robot>
박스 toy이가 인스턴스 인자로 오면 상관 없지만 컴파일러는 걱정을 한다 토이 말고 다른애가 올까봐
토이는 카의 상위 클래스 부모 클래스를 인자로 받아들일 수 없다























